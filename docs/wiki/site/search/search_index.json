{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction MCCoroutine is library which adds extensive support for Kotlin Coroutines on Minecraft Server implementing the Bukkit-API or Sponge-API . Examples for supported frameworks: Spigot Paper CraftBukkit SpongeVanilla SpongeForge Kotlin Coroutines Description Asynchronous or non-blocking programming is the new reality. Whether we're creating server-side, desktop or mobile applications, it's important that we provide an experience that is not only fluid from the user's perspective, but scalable when needed. There are many approaches to this problem, and in Kotlin we take a very flexible one by providing Coroutine support at the language level and delegating most of the functionality to libraries, much in line with Kotlin's philosophy. Source: (https://github.com/JetBrains/kotlin-web-site/blob/master/pages/docs/reference/coroutines-overview.md, Date: [09/11/2018], Licence copied to LICENCE). Features Full implementation of Kotlin Coroutines for Minecraft Server Extension functions for already established functions Connection to events, commands, schedulers Coroutine LifeCycle scope for plugins (supports plugin reloading) No NMS Support for Minecraft 1.7 - Latest Support for Java 8 - Latest Getting started Take a look at the next page to get started with integrating MCCoroutine into your plugin.","title":"Home"},{"location":"#introduction","text":"MCCoroutine is library which adds extensive support for Kotlin Coroutines on Minecraft Server implementing the Bukkit-API or Sponge-API . Examples for supported frameworks: Spigot Paper CraftBukkit SpongeVanilla SpongeForge Kotlin Coroutines Description Asynchronous or non-blocking programming is the new reality. Whether we're creating server-side, desktop or mobile applications, it's important that we provide an experience that is not only fluid from the user's perspective, but scalable when needed. There are many approaches to this problem, and in Kotlin we take a very flexible one by providing Coroutine support at the language level and delegating most of the functionality to libraries, much in line with Kotlin's philosophy. Source: (https://github.com/JetBrains/kotlin-web-site/blob/master/pages/docs/reference/coroutines-overview.md, Date: [09/11/2018], Licence copied to LICENCE).","title":"Introduction"},{"location":"#features","text":"Full implementation of Kotlin Coroutines for Minecraft Server Extension functions for already established functions Connection to events, commands, schedulers Coroutine LifeCycle scope for plugins (supports plugin reloading) No NMS Support for Minecraft 1.7 - Latest Support for Java 8 - Latest","title":"Features"},{"location":"#getting-started","text":"Take a look at the next page to get started with integrating MCCoroutine into your plugin.","title":"Getting started"},{"location":"BRIDGE/","text":"Bridging non-suspendable functions to suspendable functions This guide continues the guide 'Creating a new Plugin' and describes how to bridge non suspendable code with suspendable implementations. 1. Adding plugin launch Use the extension method plugin.launch{} to enter a suspendable context on the bukkit primary thread. class Foo ( private val plugin : Plugin ) { fun bar () { val job = plugin . launch { delay ( 1000 ) bob () } } private suspend fun bob (){ } } 2. Understanding the execution order. By allowing to append suspend to your listeners and command executors it is highly unlikely that you need to use this function. Still, it is important to understand the execution order in this case. class Foo ( private val plugin : Plugin ) { fun bar () { println ( \"I am first\" ) val job = plugin . launch { println ( \"I am second\" ) // The context is not suspended when switched to the same suspendable context. delay ( 1000 ) println ( \"I am fourth\" ) // The context is given back after 1000 milliseconds and continuous here. bob () } // When calling delay the suspendable context is suspended and the original context immediately continuous here. println ( \"I am third\" ) } private suspend fun bob (){ println ( \"I am fifth\" ) } } \"I am first \" I am second \"I am third\" \"I am fifth\" 3. Do not use runBlocking Using runBlocking in production code is very bad as it annihilates any improvements, we have made by using coroutines. MCCoroutine manipulates the Bukkit Scheduler to rescue the Bukkit Primary Thread Context if it is being used but plugin.launch{} is almost always the function you want to use instead. 4. Test the Foo class Connect to the foo class in any way and call it for testing. The next page continuous by adding caches to the plugin.","title":"Bridging non-suspendable functions to suspendable functions"},{"location":"BRIDGE/#bridging-non-suspendable-functions-to-suspendable-functions","text":"This guide continues the guide 'Creating a new Plugin' and describes how to bridge non suspendable code with suspendable implementations.","title":"Bridging non-suspendable functions to suspendable functions"},{"location":"BRIDGE/#1-adding-plugin-launch","text":"Use the extension method plugin.launch{} to enter a suspendable context on the bukkit primary thread. class Foo ( private val plugin : Plugin ) { fun bar () { val job = plugin . launch { delay ( 1000 ) bob () } } private suspend fun bob (){ } }","title":"1. Adding plugin launch"},{"location":"BRIDGE/#2-understanding-the-execution-order","text":"By allowing to append suspend to your listeners and command executors it is highly unlikely that you need to use this function. Still, it is important to understand the execution order in this case. class Foo ( private val plugin : Plugin ) { fun bar () { println ( \"I am first\" ) val job = plugin . launch { println ( \"I am second\" ) // The context is not suspended when switched to the same suspendable context. delay ( 1000 ) println ( \"I am fourth\" ) // The context is given back after 1000 milliseconds and continuous here. bob () } // When calling delay the suspendable context is suspended and the original context immediately continuous here. println ( \"I am third\" ) } private suspend fun bob (){ println ( \"I am fifth\" ) } } \"I am first \" I am second \"I am third\" \"I am fifth\"","title":"2. Understanding the execution order."},{"location":"BRIDGE/#3-do-not-use-runblocking","text":"Using runBlocking in production code is very bad as it annihilates any improvements, we have made by using coroutines. MCCoroutine manipulates the Bukkit Scheduler to rescue the Bukkit Primary Thread Context if it is being used but plugin.launch{} is almost always the function you want to use instead.","title":"3. Do not use runBlocking"},{"location":"BRIDGE/#4-test-the-foo-class","text":"Connect to the foo class in any way and call it for testing. The next page continuous by adding caches to the plugin.","title":"4. Test the Foo class"},{"location":"CACHING/","text":"Advanced Topic: Caching This guide continues the guide 'Creating a new Plugin' and describes how the caching strategy lazy loading can be used together with coroutines. 1. Add a simple cache When taking a look at the Database implementation from before, we can observe quite a lot of redundant database accesses when a player rejoins a server in a very short time. For this, we put a lazy-loading cache in front of the Database implementation. class DatabaseCache ( private val database : Database ) { private val cache = HashMap < Player , Deferred < PlayerData >> () suspend fun getDataFromPlayer ( player : Player ): PlayerData { } } 2. Deferred PlayerData Instead of using the type PlayerData directly, we use the type Deferred which is the representation of a non-blocking job which has got PlayerData as result. This means we essentially store the job of retrieving data from the database into the cache. class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( plugin . minecraftDispatcher ) { database . getDataFromPlayer ( playerJoinEvent . player ) } } // Await suspends the current context until the value of the ``Deferred`` job is ready. cache [ player ]!! . await () } } } 3. Clear the cache Clearing the cache is as simple as adding a clear method. class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () fun clear () { cache . clear () } suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( plugin . minecraftDispatcher ) { database . getDataFromPlayer ( playerJoinEvent . player ) } } // Await suspends the current context until the value of the ``Deferred`` job is ready. cache [ player ]!! . await () } } } 4. Adding auto save of cache It is possible to add a new repeatable task to save the cached data every 10 minutes. class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () init { plugin . launch { while ( true ) { // Save all cached player data every 10 minutes. for ( player in cache . keys . toTypedArray ()) { database . saveData ( player , cache [ player ]!! . await ()) // Remove player when no longer online if ( ! player . isOnline ) { cache . remove ( player ) } } delay ( 10 * 60 * 1000 ) // 10 minutes } } } fun clear () { cache . clear () } suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( plugin . minecraftDispatcher ) { database . getDataFromPlayer ( playerJoinEvent . player ) } } // Await suspends the current context until the value of the ``Deferred`` job is ready. cache [ player ]!! . await () } } } 5. Update PlayerDataListener It is no longer necessary to manually call save as auto save is put in place. Also, the cache automatically clears itself up every 10 minutes. class PlayerDataListener ( private val database : DatabaseCache ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( playerJoinEvent : PlayerJoinEvent ) { val playerData = database . getDataFromPlayer ( playerJoinEvent . player ) playerData . name = player . name playerData . lastJoinDate = Date () } } 4. Test the Cache Join and leave your server to observe changes on your database.","title":"Caching Database Results"},{"location":"CACHING/#advanced-topic-caching","text":"This guide continues the guide 'Creating a new Plugin' and describes how the caching strategy lazy loading can be used together with coroutines.","title":"Advanced Topic: Caching"},{"location":"CACHING/#1-add-a-simple-cache","text":"When taking a look at the Database implementation from before, we can observe quite a lot of redundant database accesses when a player rejoins a server in a very short time. For this, we put a lazy-loading cache in front of the Database implementation. class DatabaseCache ( private val database : Database ) { private val cache = HashMap < Player , Deferred < PlayerData >> () suspend fun getDataFromPlayer ( player : Player ): PlayerData { } }","title":"1. Add a simple cache"},{"location":"CACHING/#2-deferred-playerdata","text":"Instead of using the type PlayerData directly, we use the type Deferred which is the representation of a non-blocking job which has got PlayerData as result. This means we essentially store the job of retrieving data from the database into the cache. class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( plugin . minecraftDispatcher ) { database . getDataFromPlayer ( playerJoinEvent . player ) } } // Await suspends the current context until the value of the ``Deferred`` job is ready. cache [ player ]!! . await () } } }","title":"2. Deferred PlayerData"},{"location":"CACHING/#3-clear-the-cache","text":"Clearing the cache is as simple as adding a clear method. class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () fun clear () { cache . clear () } suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( plugin . minecraftDispatcher ) { database . getDataFromPlayer ( playerJoinEvent . player ) } } // Await suspends the current context until the value of the ``Deferred`` job is ready. cache [ player ]!! . await () } } }","title":"3. Clear the cache"},{"location":"CACHING/#4-adding-auto-save-of-cache","text":"It is possible to add a new repeatable task to save the cached data every 10 minutes. class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () init { plugin . launch { while ( true ) { // Save all cached player data every 10 minutes. for ( player in cache . keys . toTypedArray ()) { database . saveData ( player , cache [ player ]!! . await ()) // Remove player when no longer online if ( ! player . isOnline ) { cache . remove ( player ) } } delay ( 10 * 60 * 1000 ) // 10 minutes } } } fun clear () { cache . clear () } suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( plugin . minecraftDispatcher ) { database . getDataFromPlayer ( playerJoinEvent . player ) } } // Await suspends the current context until the value of the ``Deferred`` job is ready. cache [ player ]!! . await () } } }","title":"4. Adding auto save of cache"},{"location":"CACHING/#5-update-playerdatalistener","text":"It is no longer necessary to manually call save as auto save is put in place. Also, the cache automatically clears itself up every 10 minutes. class PlayerDataListener ( private val database : DatabaseCache ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( playerJoinEvent : PlayerJoinEvent ) { val playerData = database . getDataFromPlayer ( playerJoinEvent . player ) playerData . name = player . name playerData . lastJoinDate = Date () } }","title":"5. Update PlayerDataListener"},{"location":"CACHING/#4-test-the-cache","text":"Join and leave your server to observe changes on your database.","title":"4. Test the Cache"},{"location":"COMMANDEXECUTORS/","text":"Adding Suspending CommandExecutors This guide continues the guide 'Creating a new Plugin' and describes how command executors can be used to edit player data. 1. Create the CommandExecutor class Create a traditional CommandExecutor but implement SuspendingCommandExecutor instead of CommandExecutor . Please consider that the return value true is automatically assumed if the function is suspended in one branch. class PlayerDataCommandExecutor ( private val database : Database ) : SuspendingCommandExecutor { override suspend fun onCommand ( sender : CommandSender , command : Command , label : String , args : Array < out String > ): Boolean { if ( sender !is Player ) { return false } if ( args . size == 2 && args [ 0 ] . equals ( \"rename\" , true )) { val name = args [ 1 ] val playerData = database . getDataFromPlayer ( sender ) playerData . name = name database . saveData ( player , playerData ) return true } return false } } 2. Connect JavaPlugin and PlayerDataCommandExecutor Instead of using setExecutor , use the provided extension method setSuspendingExecutor to allow to register a suspendable command executor. class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), plugin ) getCommand ( \"playerdata\" ) !! . setSuspendingExecutor ( PlayerDataCommandExecutor ( database )) } override suspend fun onDisableAsync () { } } 3. Test the CommandExecutor Join your server and enter the playerData command to edit your player data. The next page continuous by adding repeating and delayed tasks to the plugin.","title":"Suspending CommandExecutors"},{"location":"COMMANDEXECUTORS/#adding-suspending-commandexecutors","text":"This guide continues the guide 'Creating a new Plugin' and describes how command executors can be used to edit player data.","title":"Adding Suspending CommandExecutors"},{"location":"COMMANDEXECUTORS/#1-create-the-commandexecutor-class","text":"Create a traditional CommandExecutor but implement SuspendingCommandExecutor instead of CommandExecutor . Please consider that the return value true is automatically assumed if the function is suspended in one branch. class PlayerDataCommandExecutor ( private val database : Database ) : SuspendingCommandExecutor { override suspend fun onCommand ( sender : CommandSender , command : Command , label : String , args : Array < out String > ): Boolean { if ( sender !is Player ) { return false } if ( args . size == 2 && args [ 0 ] . equals ( \"rename\" , true )) { val name = args [ 1 ] val playerData = database . getDataFromPlayer ( sender ) playerData . name = name database . saveData ( player , playerData ) return true } return false } }","title":"1. Create the CommandExecutor class"},{"location":"COMMANDEXECUTORS/#2-connect-javaplugin-and-playerdatacommandexecutor","text":"Instead of using setExecutor , use the provided extension method setSuspendingExecutor to allow to register a suspendable command executor. class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), plugin ) getCommand ( \"playerdata\" ) !! . setSuspendingExecutor ( PlayerDataCommandExecutor ( database )) } override suspend fun onDisableAsync () { } }","title":"2. Connect JavaPlugin and PlayerDataCommandExecutor"},{"location":"COMMANDEXECUTORS/#3-test-the-commandexecutor","text":"Join your server and enter the playerData command to edit your player data. The next page continuous by adding repeating and delayed tasks to the plugin.","title":"3. Test the CommandExecutor"},{"location":"LISTENER/","text":"Adding Suspending Listeners This guide continues the guide 'Creating a new Plugin' and describes how listeners can be used to load and save player data. 1. Create the Listener class Create a traditional listener and add suspend to all functions where you perform suspendable operations (e.g. calling other suspend functions). You can mix suspendable and non suspendable functions in listeners. class PlayerDataListener ( private val database : Database ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( playerJoinEvent : PlayerJoinEvent ) { val playerData = database . getDataFromPlayer ( playerJoinEvent . player ) playerData . name = player . name playerData . lastJoinDate = Date () database . saveData ( player , playerData ) } @EventHandler suspend fun onPlayerQuitEvent ( playerQuitEvent : PlayerQuitEvent ) { val playerData = database . getDataFromPlayer ( playerQuitEvent . player ) playerData . name = player . name playerData . lastQuitDate = Date () database . saveData ( player , playerData ) } } 2. Connect JavaPlugin and PlayerDataListener Instead of using registerEvents , use the provided extension method registerSuspendingEvents to allow suspendable functions in your listener. Please consider, that timing measurements are no longer accurate for suspendable functions. class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), plugin ) } override suspend fun onDisableAsync () { } } 3. Test the Listener Join and leave your server to observe changes on your database. The next page continuous by adding command executors to the plugin.","title":"Suspending Listeners"},{"location":"LISTENER/#adding-suspending-listeners","text":"This guide continues the guide 'Creating a new Plugin' and describes how listeners can be used to load and save player data.","title":"Adding Suspending Listeners"},{"location":"LISTENER/#1-create-the-listener-class","text":"Create a traditional listener and add suspend to all functions where you perform suspendable operations (e.g. calling other suspend functions). You can mix suspendable and non suspendable functions in listeners. class PlayerDataListener ( private val database : Database ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( playerJoinEvent : PlayerJoinEvent ) { val playerData = database . getDataFromPlayer ( playerJoinEvent . player ) playerData . name = player . name playerData . lastJoinDate = Date () database . saveData ( player , playerData ) } @EventHandler suspend fun onPlayerQuitEvent ( playerQuitEvent : PlayerQuitEvent ) { val playerData = database . getDataFromPlayer ( playerQuitEvent . player ) playerData . name = player . name playerData . lastQuitDate = Date () database . saveData ( player , playerData ) } }","title":"1. Create the Listener class"},{"location":"LISTENER/#2-connect-javaplugin-and-playerdatalistener","text":"Instead of using registerEvents , use the provided extension method registerSuspendingEvents to allow suspendable functions in your listener. Please consider, that timing measurements are no longer accurate for suspendable functions. class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), plugin ) } override suspend fun onDisableAsync () { } }","title":"2. Connect JavaPlugin and PlayerDataListener"},{"location":"LISTENER/#3-test-the-listener","text":"Join and leave your server to observe changes on your database. The next page continuous by adding command executors to the plugin.","title":"3. Test the Listener"},{"location":"NEWPLUGIN/","text":"Creating a new Plugin This guide deals with an example where a new plugin is developed from scratch using MCCoroutine to handle asynchronous and synchronous code. MCCoroutine can be easily integrated into existing plugins but this guide only deals with a new plugin. 1. Understanding the goal We want to create a new plugin which stores/retrieves the following user data into/from a database when a user enters our Bukkit-API based server. UUID Player Name Last Join Date Last Quit Date 2. Include MCCoroutine and Kotlin Coroutines This example plugin uses gradle as a build system. For more details see the Started Page . Gradle dependencies { implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-api:1.2.0\" ) implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-core:1.2.0\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.10\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.3.10\" ) } 3. Create the Java Plugin class Here the first decision is to decide between extending JavaPlugin or SuspendingJavaPlugin which is a new base class extending JavaPlugin . Here is an easy rule to follow: If you want to perform async operations or call other suspending functions from your plugin class, go with the newly available type SuspendingJavaPlugin otherwise use JavaPlugin . class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { override suspend fun onEnableAsync () { } override suspend fun onDisableAsync () { } } How onEnableAsync works The implementation which calls the onEnableAsync function manipulates the Bukkit Server implementation in the following way: * If a context switch is made, it blocks the entire minecraft-server thread until the context is given back. This means in this method you can switch contexts as you like but the plugin is not considered enabled until the context is given back. * It allows for a clean startup as the plugin is not considered \"enabled\" until the context is given back. * Other plugins which are already enabled, may or may not already perform work in the background. * Plugins which may get enabled in the future, wait until this plugin is enabled. 3. Create Database and PlayerData class class PlayerData ( var uuid : UUID , var name : String , var lastJoinDate : Date , var lastQuitDate : Date ) { } Here, we perform all database operations on the IO context provided by Kotlin Coroutines. The result is automatically returned to the Bukkit primary thread. class Database { suspend fun createDbIfNotExist () { withContext ( Dispatchers . IO ){ // ... create tables } } suspend fun getDataFromPlayer ( player : Player ) : PlayerData { val playerData = withContext ( Dispatchers . IO ) { // ... get from database by player uuid or create new playerData instance. PlayerData ( uuid , name , lastJoinDate ) } return playerData ; } suspend fun saveData ( player : Player , playerData : PlayerData ) { withContext ( Dispatchers . IO ){ // insert or update playerData } } } 4. Connect JavaPlugin and Database Create a new instance of the database and call it in the onEnable function. class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { database . createDbIfNotExist () } override suspend fun onDisableAsync () { } } 5. Test the Java Plugin Start your server to observe changes on your database. The next page continuous by adding listeners to the plugin.","title":"Creating a new Plugin"},{"location":"NEWPLUGIN/#creating-a-new-plugin","text":"This guide deals with an example where a new plugin is developed from scratch using MCCoroutine to handle asynchronous and synchronous code. MCCoroutine can be easily integrated into existing plugins but this guide only deals with a new plugin.","title":"Creating a new Plugin"},{"location":"NEWPLUGIN/#1-understanding-the-goal","text":"We want to create a new plugin which stores/retrieves the following user data into/from a database when a user enters our Bukkit-API based server. UUID Player Name Last Join Date Last Quit Date","title":"1. Understanding the goal"},{"location":"NEWPLUGIN/#2-include-mccoroutine-and-kotlin-coroutines","text":"This example plugin uses gradle as a build system. For more details see the Started Page . Gradle dependencies { implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-api:1.2.0\" ) implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-core:1.2.0\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.10\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.3.10\" ) }","title":"2. Include MCCoroutine and Kotlin Coroutines"},{"location":"NEWPLUGIN/#3-create-the-java-plugin-class","text":"Here the first decision is to decide between extending JavaPlugin or SuspendingJavaPlugin which is a new base class extending JavaPlugin . Here is an easy rule to follow: If you want to perform async operations or call other suspending functions from your plugin class, go with the newly available type SuspendingJavaPlugin otherwise use JavaPlugin . class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { override suspend fun onEnableAsync () { } override suspend fun onDisableAsync () { } } How onEnableAsync works The implementation which calls the onEnableAsync function manipulates the Bukkit Server implementation in the following way: * If a context switch is made, it blocks the entire minecraft-server thread until the context is given back. This means in this method you can switch contexts as you like but the plugin is not considered enabled until the context is given back. * It allows for a clean startup as the plugin is not considered \"enabled\" until the context is given back. * Other plugins which are already enabled, may or may not already perform work in the background. * Plugins which may get enabled in the future, wait until this plugin is enabled.","title":"3. Create the Java Plugin class"},{"location":"NEWPLUGIN/#3-create-database-and-playerdata-class","text":"class PlayerData ( var uuid : UUID , var name : String , var lastJoinDate : Date , var lastQuitDate : Date ) { } Here, we perform all database operations on the IO context provided by Kotlin Coroutines. The result is automatically returned to the Bukkit primary thread. class Database { suspend fun createDbIfNotExist () { withContext ( Dispatchers . IO ){ // ... create tables } } suspend fun getDataFromPlayer ( player : Player ) : PlayerData { val playerData = withContext ( Dispatchers . IO ) { // ... get from database by player uuid or create new playerData instance. PlayerData ( uuid , name , lastJoinDate ) } return playerData ; } suspend fun saveData ( player : Player , playerData : PlayerData ) { withContext ( Dispatchers . IO ){ // insert or update playerData } } }","title":"3. Create Database and PlayerData class"},{"location":"NEWPLUGIN/#4-connect-javaplugin-and-database","text":"Create a new instance of the database and call it in the onEnable function. class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { database . createDbIfNotExist () } override suspend fun onDisableAsync () { } }","title":"4. Connect JavaPlugin and Database"},{"location":"NEWPLUGIN/#5-test-the-java-plugin","text":"Start your server to observe changes on your database. The next page continuous by adding listeners to the plugin.","title":"5. Test the Java Plugin"},{"location":"REPEATINGTASK/","text":"Adding delayed and repeating tasks This guide continues the guide 'Creating a new Plugin' and describes how delayed and repeating tasks can be performed with coroutines. 1. Create MiniGame class Create a new class which implements a custom MiniGame which allows players to join when it has not started yet. class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () fun join ( player : Player ) { if ( isStarted ) { return ; } players . add ( player ) } } 2. Add a start function to the MiniGame class Using delay() we can delay the current context (Bukkit primary thread) by 1000 milliseconds, to easily generate a countdown without blocking the server. delay() essentially suspends the current context and continuous after the given time. class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () fun join ( player : Player ) { if ( isStarted ) { return } players . add ( player ) } suspend fun start () { if ( isStarted ) { return } isStarted = true for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. } private fun sendMessageToPlayers ( message : String ) { players . forEach { p -> p . sendMessage ( message ) } } } 3. Add a run function to the MiniGame class We can extend the start method to call run which contains a loop to tick the miniGame every 1 second. class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 //... suspend fun start () { if ( isStarted ) { return } isStarted = true for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. run () } private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } } //... } 4. Add a function to stop the game. An admin should be able to cancel the minigame which we implement by a stop function. class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 //... private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } if ( ! isStarted ) { sendMessageToPlayers ( \"Game was cancelled by external stop.\" ) } isStarted = false // ... Teleport players back to lobby. } fun stop () { if ( ! isStarted ) { return } isStarted = false } //... } 5. The full MiniGame class class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 fun join ( player : Player ) { if ( isStarted ) { return } players . add ( player ) } suspend fun start () { if ( isStarted ) { return } isStarted = true for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. run () } private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } if ( ! isStarted ) { sendMessageToPlayers ( \"Game was cancelled by external stop.\" ) } isStarted = false // ... Teleport players back to lobby. } fun stop () { if ( ! isStarted ) { return } isStarted = false } private fun sendMessageToPlayers ( message : String ) { players . forEach { p -> p . sendMessage ( message ) } } } 6. Connect JavaPlugin, Listener and MiniGame class MiniGameListener ( private val miniGame : MiniGame ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( playerJoinEvent : PlayerJoinEvent ) { miniGame . join ( playerJoinEvent . player ) // Just for testing purposes miniGame . start () } } class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () private val miniGame = MiniGame () override suspend fun onEnableAsync () { database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), plugin ) getCommand ( \"playerdata\" ) !! . setSuspendingExecutor ( PlayerDataCommandExecutor ( database )) server . pluginManager . registerSuspendingEvents ( MiniGameListener ( minigame ), plugin ) } override suspend fun onDisableAsync () { } } 7. Test the MiniGame Join your server to observe messages about a MiniGame being sent to you. The next page continuous by adding caches to the plugin.","title":"Suspending Delayed, Repeating Tasks"},{"location":"REPEATINGTASK/#adding-delayed-and-repeating-tasks","text":"This guide continues the guide 'Creating a new Plugin' and describes how delayed and repeating tasks can be performed with coroutines.","title":"Adding delayed and repeating tasks"},{"location":"REPEATINGTASK/#1-create-minigame-class","text":"Create a new class which implements a custom MiniGame which allows players to join when it has not started yet. class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () fun join ( player : Player ) { if ( isStarted ) { return ; } players . add ( player ) } }","title":"1. Create MiniGame class"},{"location":"REPEATINGTASK/#2-add-a-start-function-to-the-minigame-class","text":"Using delay() we can delay the current context (Bukkit primary thread) by 1000 milliseconds, to easily generate a countdown without blocking the server. delay() essentially suspends the current context and continuous after the given time. class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () fun join ( player : Player ) { if ( isStarted ) { return } players . add ( player ) } suspend fun start () { if ( isStarted ) { return } isStarted = true for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. } private fun sendMessageToPlayers ( message : String ) { players . forEach { p -> p . sendMessage ( message ) } } }","title":"2. Add a start function to the MiniGame class"},{"location":"REPEATINGTASK/#3-add-a-run-function-to-the-minigame-class","text":"We can extend the start method to call run which contains a loop to tick the miniGame every 1 second. class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 //... suspend fun start () { if ( isStarted ) { return } isStarted = true for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. run () } private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } } //... }","title":"3. Add a run function to the MiniGame class"},{"location":"REPEATINGTASK/#4-add-a-function-to-stop-the-game","text":"An admin should be able to cancel the minigame which we implement by a stop function. class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 //... private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } if ( ! isStarted ) { sendMessageToPlayers ( \"Game was cancelled by external stop.\" ) } isStarted = false // ... Teleport players back to lobby. } fun stop () { if ( ! isStarted ) { return } isStarted = false } //... }","title":"4. Add a function to stop the game."},{"location":"REPEATINGTASK/#5-the-full-minigame-class","text":"class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 fun join ( player : Player ) { if ( isStarted ) { return } players . add ( player ) } suspend fun start () { if ( isStarted ) { return } isStarted = true for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. run () } private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } if ( ! isStarted ) { sendMessageToPlayers ( \"Game was cancelled by external stop.\" ) } isStarted = false // ... Teleport players back to lobby. } fun stop () { if ( ! isStarted ) { return } isStarted = false } private fun sendMessageToPlayers ( message : String ) { players . forEach { p -> p . sendMessage ( message ) } } }","title":"5. The full MiniGame class"},{"location":"REPEATINGTASK/#6-connect-javaplugin-listener-and-minigame","text":"class MiniGameListener ( private val miniGame : MiniGame ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( playerJoinEvent : PlayerJoinEvent ) { miniGame . join ( playerJoinEvent . player ) // Just for testing purposes miniGame . start () } } class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () private val miniGame = MiniGame () override suspend fun onEnableAsync () { database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), plugin ) getCommand ( \"playerdata\" ) !! . setSuspendingExecutor ( PlayerDataCommandExecutor ( database )) server . pluginManager . registerSuspendingEvents ( MiniGameListener ( minigame ), plugin ) } override suspend fun onDisableAsync () { } }","title":"6. Connect JavaPlugin, Listener and MiniGame"},{"location":"REPEATINGTASK/#7-test-the-minigame","text":"Join your server to observe messages about a MiniGame being sent to you. The next page continuous by adding caches to the plugin.","title":"7. Test the MiniGame"},{"location":"STARTED/","text":"Getting Started In order to access the MCCoroutine Kotlin API, you need to include the following libraries to your project. Kotlin Coroutines Description Please notice that these are the libraries for Bukkit-API based servers. If you are looking for the Sponge-API, simply replace bukkit with sponge in name of the dependencies. e.g. 'com.github.shynixn.mccoroutine:mccoroutine-sponge-api: x.x.x' 1. Add MCCoroutine Gradle dependencies { implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-api:1.2.0\" ) implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-core:1.2.0\" ) } Maven <dependency> <groupId> com.github.shynixn.mccoroutine </groupId> <artifactId> mccoroutine-bukkit-api </artifactId> <version> 1.2.0 </version> <scope> compile </scope> </dependency> <dependency> <groupId> com.github.shynixn.mccoroutine </groupId> <artifactId> mccoroutine-bukkit-core </artifactId> <version> 1.2.0 </version> <scope> compile </scope> </dependency> 2. Add the official Kotlin Coroutines libraries MCCoroutine builds against Kotlin 1.3.x but does not ship the Kotlin Runtime or Kotlin Coroutines Runtime. This means you are free to choose any ship your Kotlin Runtime as you like as long it is >= 1.3.0. Replace 1.x.x with the actual versions. Gradle dependencies { implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.x.x\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.x.x\" ) } Maven <dependency> <groupId> org.jetbrains.kotlinx </groupId> <artifactId> kotlinx-coroutines-core </artifactId> <version> 1.x.x </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.jetbrains.kotlinx </groupId> <artifactId> kotlinx-coroutines-jdk8 </artifactId> <version> 1.x.x </version> <scope> compile </scope> </dependency> 3. Test if everything is working Try to call launch{} in your onEnable() function in your Plugin class.","title":"Getting Started"},{"location":"STARTED/#getting-started","text":"In order to access the MCCoroutine Kotlin API, you need to include the following libraries to your project. Kotlin Coroutines Description Please notice that these are the libraries for Bukkit-API based servers. If you are looking for the Sponge-API, simply replace bukkit with sponge in name of the dependencies. e.g. 'com.github.shynixn.mccoroutine:mccoroutine-sponge-api: x.x.x'","title":"Getting Started"},{"location":"STARTED/#1-add-mccoroutine","text":"Gradle dependencies { implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-api:1.2.0\" ) implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-core:1.2.0\" ) } Maven <dependency> <groupId> com.github.shynixn.mccoroutine </groupId> <artifactId> mccoroutine-bukkit-api </artifactId> <version> 1.2.0 </version> <scope> compile </scope> </dependency> <dependency> <groupId> com.github.shynixn.mccoroutine </groupId> <artifactId> mccoroutine-bukkit-core </artifactId> <version> 1.2.0 </version> <scope> compile </scope> </dependency>","title":"1. Add MCCoroutine"},{"location":"STARTED/#2-add-the-official-kotlin-coroutines-libraries","text":"MCCoroutine builds against Kotlin 1.3.x but does not ship the Kotlin Runtime or Kotlin Coroutines Runtime. This means you are free to choose any ship your Kotlin Runtime as you like as long it is >= 1.3.0. Replace 1.x.x with the actual versions. Gradle dependencies { implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.x.x\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.x.x\" ) } Maven <dependency> <groupId> org.jetbrains.kotlinx </groupId> <artifactId> kotlinx-coroutines-core </artifactId> <version> 1.x.x </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.jetbrains.kotlinx </groupId> <artifactId> kotlinx-coroutines-jdk8 </artifactId> <version> 1.x.x </version> <scope> compile </scope> </dependency>","title":"2. Add the official Kotlin Coroutines libraries"},{"location":"STARTED/#3-test-if-everything-is-working","text":"Try to call launch{} in your onEnable() function in your Plugin class.","title":"3. Test if everything is working"}]}