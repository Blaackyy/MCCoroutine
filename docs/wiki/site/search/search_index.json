{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>MCCoroutine is a library, which adds extensive support for Kotlin Coroutines for Minecraft Server environments.</p> <p>Plugins for game servers and proxy servers often need to perform asynchronous operations (e.g. accessing databases) to  be scalable for a large amount of players. MCCoroutine brings the full power of Kotlin Coroutines to them by extending  the existing APIs with suspendable commands, events and schedules.</p> <p>Kotlin Coroutines</p> <p>Asynchronous or non-blocking programming is the new reality. Whether we're creating server-side, desktop or mobile applications, it's important that we provide an experience that is not only fluid from the user's perspective, but scalable when needed. There are many approaches to this problem, and in Kotlin we take a very flexible one by providing Coroutine support at the language level and delegating most of the functionality to libraries, much in line with Kotlin's philosophy. Source: (https://github.com/JetBrains/kotlin-web-site/blob/master/pages/docs/reference/coroutines-overview.md, Date: [09/11/2018], Licence copied to LICENCE).</p> <p>Supported Game Servers:</p> <ul> <li>Spigot</li> <li>Paper</li> <li>CraftBukkit</li> <li>SpongeVanilla</li> <li>SpongeForge</li> <li>Minestom</li> </ul> <p>Supported Proxies:</p> <ul> <li>BungeeCord</li> <li>Waterfall</li> <li>Velocity</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Full implementation of Kotlin Coroutines for Minecraft Servers and Minecraft Proxies</li> <li>Extension functions for already established functions</li> <li>Connection to events, commands, schedulers</li> <li>Coroutine LifeCycle scope for plugins (supports plugin reloading)</li> <li>No NMS</li> <li>Support for Minecraft 1.7 - Latest</li> <li>Support for Java 8 - Latest</li> </ul>"},{"location":"caching/","title":"Suspending Caches, Background Repeating Tasks","text":"<p>This page explains how you can create a <code>lazy-loading</code> cache using Kotlin Coroutines.</p> <p>In minecraft plugins, players can perform many actions in a short time period. If plugins want to keep track of them and store every action in the database, creating a new database call for every single action may cause performance problems. Therefore, caches are often implemented, which is a lot easier when using coroutines.</p>"},{"location":"caching/#implementing-a-cache-bukkit","title":"Implementing a Cache (Bukkit)","text":"<p>When taking a look at the <code>Database</code> implementation below, we can observe quite a lot of redundant database accesses when a player rejoins a server in a very short timeframe.</p> <p>For this, we put a <code>lazy-loading</code> cache in front of the  <code>Database</code> implementation.</p> <pre><code>class Database() {\nfun createDbIfNotExist() {\n// ... SQL calls\n}\n\nfun getDataFromPlayer(player : Player) : PlayerData {\n// ... SQL calls\n}\n\nfun saveData(player : Player, playerData : PlayerData) {\n// ... SQL calls\n}\n}\n</code></pre> <pre><code>import kotlinx.coroutines.Deferred\nimport org.bukkit.entity.Player\n\nclass DatabaseCache(private val database: Database) {\nprivate val cache = HashMap&lt;Player, Deferred&lt;PlayerData&gt;&gt;()\n\nsuspend fun getDataFromPlayer(player: Player): PlayerData {\n}\n}\n</code></pre>"},{"location":"caching/#deferred-playerdata","title":"Deferred PlayerData","text":"<p>Instead of using the type <code>PlayerData</code> directly, we use the type <code>Deferred</code>, which is the representation of a non-blocking job which has got <code>PlayerData</code> as result. This means we essentially store the job of retrieving data from the database into the cache.</p> <pre><code>import kotlinx.coroutines.*\nimport org.bukkit.entity.Player\nimport org.bukkit.plugin.Plugin\n\nclass DatabaseCache(private val database: Database, private val plugin: Plugin) {\nprivate val cache = HashMap&lt;Player, Deferred&lt;PlayerData&gt;&gt;()\n\nsuspend fun getDataFromPlayer(player: Player): PlayerData {\nreturn coroutineScope {\nif (!cache.containsKey(player)) {\n// Cache miss, create a new job\ncache[player] = async(Dispatchers.IO) {\ndatabase.getDataFromPlayer(player)\n}\n}\n\n// Await suspends the current context until the value of the Deferred job is ready.\ncache[player]!!.await()\n}\n}\n}\n</code></pre>"},{"location":"caching/#implementing-cache-clearing","title":"Implementing cache clearing","text":"<p>Clearing the cache is as simple as adding a <code>clear</code> method.</p> <pre><code>import kotlinx.coroutines.*\nimport org.bukkit.entity.Player\nimport org.bukkit.plugin.Plugin\n\nclass DatabaseCache(private val database: Database, private val plugin: Plugin) {\nprivate val cache = HashMap&lt;Player, Deferred&lt;PlayerData&gt;&gt;()\n\nfun clear() {\ncache.clear()\n}\n\nsuspend fun getDataFromPlayer(player: Player): PlayerData {\nreturn coroutineScope {\nif (!cache.containsKey(player)) {\n// Cache miss, create a new job\ncache[player] = async(Dispatchers.IO) {\ndatabase.getDataFromPlayer(player)\n}\n}\n\n// Await suspends the current context until the value of the ``Deferred`` job is ready.\ncache[player]!!.await()\n}\n}\n}\n</code></pre>"},{"location":"caching/#background-repeating-tasks","title":"Background Repeating Tasks","text":"<p>After introducing a cache, we can implement a new suspendable background task to save the cached data every 10 minutes.</p> <pre><code>import com.github.shynixn.mccoroutine.bukkit.launch\nimport kotlinx.coroutines.*\nimport org.bukkit.entity.Player\nimport org.bukkit.plugin.Plugin\n\nclass DatabaseCache(private val database: Database, private val plugin: Plugin) {\nprivate val cache = HashMap&lt;Player, Deferred&lt;PlayerData&gt;&gt;()\n\ninit {\n// This plugin.launch launches a new scope in the minecraft server context which can be understood\n// to be a background task and behaves in a similar way to Bukkit.getScheduler().runTask(plugin, Runnable {  })\nplugin.launch {\n// This background task is a repeatable task which in this case is an endless loop. The endless loop\n// is automatically stopped by MCCoroutine once you reload your plugin.\nwhile (true) {\n// Save all cached player data every 10 minutes.\nfor (player in cache.keys.toTypedArray()) {\ndatabase.saveData(player, cache[player]!!.await())\n\n// Remove player when no longer online\nif (!player.isOnline) {\ncache.remove(player)\n}\n}\n\n// Suspending the current context is important in this case otherwise the minecraft thread will only execute this\n// endless loop as it does not have time to execute other things. Delay gives the thread time to execute other things.\ndelay(10 * 60 * 1000) // 10 minutes\n}\n}\n}\n\nfun clear() {\ncache.clear()\n}\n\nsuspend fun getDataFromPlayer(player: Player): PlayerData {\nreturn coroutineScope {\nif (!cache.containsKey(player)) {\n// Cache miss, create a new job\ncache[player] = async(Dispatchers.IO) {\ndatabase.getDataFromPlayer(player)\n}\n}\n\n// Await suspends the current context until the value of the ``Deferred`` job is ready.\ncache[player]!!.await()\n}\n}\n}\n</code></pre>"},{"location":"commandexecutor/","title":"Suspending Commandexecutors","text":"<p>This page explains how you can use Kotlin Coroutines using the suspend key word for command executors in minecraft plugins.</p>"},{"location":"commandexecutor/#create-the-commandexecutor","title":"Create the CommandExecutor","text":"BukkitBungeeCordSpongeVelocityMinestom <p>Create a traditional command executor but implement <code>SuspendingCommandExecutor</code> instead of <code>CommandExecutor</code>. Please consider, that the return value <code>true</code> is automatically assumed, if the function is suspended in one branch.</p> <pre><code>import com.github.shynixn.mccoroutine.bukkit.SuspendingCommandExecutor\nimport org.bukkit.command.Command\nimport org.bukkit.command.CommandSender\nimport org.bukkit.entity.Player\n\nclass PlayerDataCommandExecutor(private val database: Database) : SuspendingCommandExecutor {\noverride suspend fun onCommand(sender: CommandSender, command: Command, label: String, args: Array&lt;out String&gt;): Boolean {\nif (sender !is Player) {\nreturn false\n}\n\nif (args.size == 2 &amp;&amp; args[0].equals(\"rename\", true)) {\nval name = args[1]\nval playerData = database.getDataFromPlayer(sender)\nplayerData.name = name\ndatabase.saveData(sender, playerData)\nreturn true\n}\n\nreturn false\n}\n}\n</code></pre> <p>Create a traditional command executor but extend from <code>SuspendingCommand</code> instead of <code>Command</code>.</p> <pre><code>import com.github.shynixn.mccoroutine.bungeecord.SuspendingCommand\nimport net.md_5.bungee.api.CommandSender\nimport net.md_5.bungee.api.connection.ProxiedPlayer\n\nclass PlayerDataCommandExecutor(private val database: Database) : SuspendingCommand(\"playerdata\") {\noverride suspend fun execute(sender: CommandSender, args: Array&lt;out String&gt;) {\nif (sender !is ProxiedPlayer) {\nreturn\n}\n\nif (args.size == 2 &amp;&amp; args[0].equals(\"rename\", true)) {\nval name = args[1]\nval playerData = database.getDataFromPlayer(sender)\nplayerData.name = name\ndatabase.saveData(sender, playerData)\nreturn\n}\n}\n}\n</code></pre> <p>Create a traditional command executor but extend from <code>SuspendingCommandExecutor</code> instead of <code>CommandExecutor</code>. Please consider, that the return value <code>CommandResult.success()</code> is automatically assumed, if the function is suspended in one branch.</p> <pre><code>import com.github.shynixn.mccoroutine.sponge.SuspendingCommandExecutor\nimport org.spongepowered.api.command.CommandResult\nimport org.spongepowered.api.command.CommandSource\nimport org.spongepowered.api.command.args.CommandContext\nimport org.spongepowered.api.entity.living.player.Player\n\nclass PlayerDataCommandExecutor(private val database: Database) : SuspendingCommandExecutor {\noverride suspend fun execute(src: CommandSource, args: CommandContext): CommandResult {\nif (src !is Player) {\nreturn CommandResult.empty()\n}\n\nif (args.hasAny(\"name\")) {\nval name = args.getOne&lt;String&gt;(\"name\").get()\nval playerData = database.getDataFromPlayer(src)\nplayerData.name = name\ndatabase.saveData(src, playerData)\nreturn CommandResult.success()\n}\n\nreturn CommandResult.empty()\n}\n}\n</code></pre> <p>There are multiple ways to create command executors in Velocity. MCCoroutine provides extensions for both the <code>SimpleCommand</code> and the <code>BrigadierCommand</code> to allow flexibility. </p> <p>A <code>SimpleCommand</code> can  be created by implementing <code>SuspendingSimpleCommand</code> instead of <code>SimpleCommand</code></p> <pre><code>import com.github.shynixn.mccoroutine.velocity.SuspendingSimpleCommand\nimport com.velocitypowered.api.command.SimpleCommand\nimport com.velocitypowered.api.proxy.Player\n\nclass PlayerDataCommandExecutor(private val database: Database) : SuspendingSimpleCommand {\noverride suspend fun execute(invocation: SimpleCommand.Invocation) {\nval source = invocation.source()\n\nif (source !is Player) {\nreturn\n}\n\nval args = invocation.arguments()\n\nif (args.size == 2 &amp;&amp; args[0].equals(\"rename\", true)) {\nval name = args[1]\nval playerData = database.getDataFromPlayer(source)\nplayerData.name = name\ndatabase.saveData(source, playerData)\nreturn\n}\n}\n}\n</code></pre> <p>A <code>BrigadierCommand</code> can be executed asynchronously using the <code>executesSuspend</code> extension function. More details below.</p> <p>Create a traditional command and user <code>server.launch</code> or <code>extension.launch</code> in the addSyntax handler.</p> <pre><code>import com.github.shynixn.mccoroutine.minestom.launch\nimport net.minestom.server.MinecraftServer\nimport net.minestom.server.command.builder.Command\nimport net.minestom.server.command.builder.arguments.ArgumentType\nimport net.minestom.server.entity.Player\n\nclass PlayerDataCommandExecutor(private val server: MinecraftServer, private val database: Database) : Command(\"mycommand\") {\ninit {\nval nameArgument = ArgumentType.String(\"name\")\naddSyntax({ sender, context -&gt;\nserver.launch {\nif (sender is Player) {\nval name : String = context.get(nameArgument)\nval playerData = database.getDataFromPlayer(sender)\nplayerData.name = name\ndatabase.saveData(sender, playerData)\n}\n}\n})\n}\n}\n</code></pre>"},{"location":"commandexecutor/#register-the-commandexecutor","title":"Register the CommandExecutor","text":"BukkitBungeeCordSpongeVelocityMinestom <p>Instead of using <code>setExecutor</code>, use the provided extension method <code>setSuspendingExecutor</code> to register a command executor.</p> <p>Important</p> <p>Do not forget to declare the <code>playerdata</code> command in your plugin.yml.</p> <pre><code>import com.github.shynixn.mccoroutine.bukkit.SuspendingJavaPlugin\nimport com.github.shynixn.mccoroutine.bukkit.registerSuspendingEvents\nimport com.github.shynixn.mccoroutine.bukkit.setSuspendingExecutor\n\nclass MCCoroutineSamplePlugin : SuspendingJavaPlugin() {\nprivate val database = Database()\n\noverride suspend fun onEnableAsync() {\n// Minecraft Main Thread\ndatabase.createDbIfNotExist()\nserver.pluginManager.registerSuspendingEvents(PlayerDataListener(database), this)\ngetCommand(\"playerdata\")!!.setSuspendingExecutor(PlayerDataCommandExecutor(database))\n}\n\noverride suspend fun onDisableAsync() {\n// Minecraft Main Thread\n}\n}\n</code></pre> <p>Instead of using <code>registerCommand</code>, use the provided extension method <code>registerSuspendingCommand</code> to register a command executor.</p> <p>Important</p> <p>Do not forget to declare the <code>playerdata</code> command in your plugin.yml.</p> <pre><code>import com.github.shynixn.mccoroutine.bungeecord.SuspendingPlugin\nimport com.github.shynixn.mccoroutine.bungeecord.registerSuspendingCommand\nimport com.github.shynixn.mccoroutine.bungeecord.registerSuspendingListener\n\nclass MCCoroutineSamplePlugin : SuspendingPlugin() {\nprivate val database = Database()\n\noverride suspend fun onEnableAsync() {\n// BungeeCord Startup Thread\ndatabase.createDbIfNotExist()\nproxy.pluginManager.registerSuspendingListener(this, PlayerDataListener(database))\nproxy.pluginManager.registerSuspendingCommand(this, PlayerDataCommandExecutor(database))\n}\n\noverride suspend fun onDisableAsync() {\n// BungeeCord Shutdown Thread (Not the same as the startup thread)\n}\n}\n</code></pre> <p>Instead of using <code>executor</code>, use the provided extension method <code>suspendingExecutor</code> to register a command executor.</p> <pre><code>import com.github.shynixn.mccoroutine.sponge.SuspendingPluginContainer\nimport com.github.shynixn.mccoroutine.sponge.registerSuspendingListeners\nimport com.github.shynixn.mccoroutine.sponge.suspendingExecutor\nimport com.google.inject.Inject\nimport org.spongepowered.api.Sponge\nimport org.spongepowered.api.command.args.GenericArguments\nimport org.spongepowered.api.command.spec.CommandSpec\nimport org.spongepowered.api.event.Listener\nimport org.spongepowered.api.event.game.state.GameStartedServerEvent\nimport org.spongepowered.api.event.game.state.GameStoppingServerEvent\nimport org.spongepowered.api.plugin.Plugin\nimport org.spongepowered.api.plugin.PluginContainer\nimport org.spongepowered.api.text.Text\n\n@Plugin(\nid = \"mccoroutinesample\",\nname = \"MCCoroutineSample\",\ndescription = \"MCCoroutineSample is sample plugin to use MCCoroutine in Sponge.\"\n)\nclass MCCoroutineSamplePlugin {\nprivate val database = Database()\n\n@Inject\nprivate lateinit var suspendingPluginContainer: SuspendingPluginContainer\n\n@Inject\nprivate lateinit var pluginContainer: PluginContainer\n\n@Listener\nsuspend fun onEnable(event: GameStartedServerEvent) {\n// Minecraft Main Thread\ndatabase.createDbIfNotExist()\nSponge.getEventManager().registerSuspendingListeners(pluginContainer, PlayerDataListener(database))\nval commandSpec = CommandSpec.builder()\n.description(Text.of(\"Command for operations.\"))\n.permission(\"mccoroutine.sample\")\n.arguments(\nGenericArguments.onlyOne(GenericArguments.string(Text.of(\"name\")))\n)\n.suspendingExecutor(pluginContainer, PlayerDataCommandExecutor(database))\nSponge.getCommandManager().register(pluginContainer, commandSpec.build(), listOf(\"playerdata\"))\n}\n\n@Listener\nsuspend fun onDisable(event: GameStoppingServerEvent) {\n// Minecraft Main Thread\n}\n}\n</code></pre> <p>Instead of using <code>register</code>, use the provided extension method <code>registerSuspend</code> to register a simple command executor.</p> <pre><code>@Plugin(\nid = \"mccoroutinesample\",\nname = \"MCCoroutineSample\",\ndescription = \"MCCoroutineSample is sample plugin to use MCCoroutine in Velocity.\"\n)\nclass MCCoroutineSamplePlugin {\nprivate val database = Database()\n\n@Inject\nlateinit var proxyServer: ProxyServer\n\n@Inject\nconstructor(suspendingPluginContainer: SuspendingPluginContainer) {\nsuspendingPluginContainer.initialize(this)\n}\n\n@Subscribe\nsuspend fun onProxyInitialization(event: ProxyInitializeEvent) {\n// Velocity Thread Pool\ndatabase.createDbIfNotExist()\nproxyServer.eventManager.registerSuspend(this, PlayerDataListener(database))\nval meta = proxyServer.commandManager.metaBuilder(\"playerdata\").build()\n\n// Register SimpleCommand\nproxyServer.commandManager.registerSuspend(meta, PlayerDataCommandExecutor(database), this)\n\n// Register BrigadierCommand\nval helloCommand =\nLiteralArgumentBuilder.literal&lt;CommandSource&gt;(\"test\")\n.executesSuspend(this, { context: CommandContext&lt;CommandSource&gt; -&gt;\nval message = Component.text(\"Hello World\", NamedTextColor.AQUA)\ncontext.getSource().sendMessage(message)\n1 // indicates success\n})\n.build()\nproxyServer.commandManager.register(BrigadierCommand(helloCommand))\n}\n}\n</code></pre> <p>Register the command in the same way as a traditional command.</p>"},{"location":"commandexecutor/#test-the-commandexecutor","title":"Test the CommandExecutor","text":"<p>Join your server and use the playerData command to observe <code>getDataFromPlayer</code> and <code>saveData</code> messages getting printed to your server log.</p>"},{"location":"coroutine/","title":"Kotlin Coroutines and Minecraft Plugins","text":"<p>When starting with Coroutines in Kotlin, it is interesting how this can be translated to the world of minecraft plugins. It is recommended to learn how Kotlin Coroutines work before you continue here.</p> <p>Important</p> <p>Make sure you have already installed MCCoroutine. See Installation for details.</p>"},{"location":"coroutine/#starting-a-coroutine","title":"Starting a coroutine","text":"<p>For beginners, it is often confusing how to enter a coroutine. The examples in the official guide mostly use <code>runBlocking</code> because it makes sense for testing. However, keep in mind to avoid using <code>runblocking</code> in any of your plugins.</p> <ul> <li>To enter a coroutine anywhere in your code at any time:</li> </ul> BukkitBungeeCordSpongeVelocityMinestom <pre><code>import com.github.shynixn.mccoroutine.bukkit.launch\nimport org.bukkit.plugin.Plugin\n\nfun foo() {\nplugin.launch {\n// This will always be on the minecraft main thread.\n}\n}\n</code></pre> <pre><code>import com.github.shynixn.mccoroutine.bungeecord.launch\nimport net.md_5.bungee.api.plugin.Plugin\n\nfun foo() {\nplugin.launch {\n// This will be a random thread on the BungeeCord threadpool\n}\n}\n</code></pre> <pre><code>import com.github.shynixn.mccoroutine.sponge.launch\nimport org.spongepowered.api.plugin.PluginContainer\n\nfun foo() {\nplugin.launch {\n// This will always be on the minecraft main thread.\n}\n}\n</code></pre> <pre><code>import com.github.shynixn.mccoroutine.velocity.launch\nimport com.velocitypowered.api.plugin.PluginContainer\n\nfun foo() {\nplugin.launch {\n// This will be a random thread on the Velocity threadpool\n}\n}\n</code></pre> <p>Minestom has got 2 lifecycle scopes, the server scope and the extension scope. When this guide talks about a <code>plugin</code>, the corresponding class in Minestom is <code>Extension</code> or <code>MinecraftServer</code> depending on your usecase.</p> <p>Server level (if you are developing a new server):</p> <pre><code>import com.github.shynixn.mccoroutine.minestom.launch\nimport net.minestom.server.MinecraftServer\n\nfun foo() {\nserver.launch {\n// This will always be on the minecraft main thread.\n}\n}\n</code></pre> <p>Extension level (if you are developing a new extension): </p> <pre><code>import com.github.shynixn.mccoroutine.minestom.launch\nimport net.minestom.server.extensions.Extension\n\nfun foo() {\nextension.launch {\n// This will always be on the minecraft main thread.\n}\n}\n</code></pre>"},{"location":"coroutine/#switching-coroutine-context","title":"Switching coroutine context","text":"<p>Later in the Coroutines in Kotlin guide, the terms coroutine-context and dispatchers are explained. A dispatcher determines what thread or threads the corresponding coroutine uses for its execution. Therefore, MCCoroutine offers 2 custom dispatchers:</p> <ul> <li>minecraftDispatcher (Allows to execute coroutines on the main minecraft thread)</li> <li>asyncDispatcher (Allows to execute coroutines on the async minecraft threadpool)</li> </ul> <p>Important</p> <p>However, it is highly recommend to use <code>Dispatchers.IO</code> instead of asyncDispatcher because the scheduling is more accurate. Additional technical details can be found here: GitHub Issue.</p> <p>An example how this works is shown below:</p> <pre><code>fun foo() {\nplugin.launch {\n// This will always be on the minecraft main thread.\n\nval result1 = withContext(plugin.minecraftDispatcher) {\n// Perform operations on the minecraft main thread.\n\"Player is \" // Optionally, return a result.\n}\n\n// Here we are automatically back on the main thread again.\n\n// Prefer using Dispatchers.IO instead of asyncDispatcher \nval result2 = withContext(Dispatchers.IO) {\n// Perform operations asynchronously.\n\" Max\"\n}\n\n// Here we are automatically back on the main thread again.\n\nprintln(result1 + result2) // Prints 'Player is Max'\n}\n}\n</code></pre> <p>Normally, you do not need to call <code>plugin.minecraftDispatcher</code> in your code. Instead, you are guaranteed to be always on the minecraft main thread in the <code>plugin.launch{}</code> scope and use sub coroutines (e.g. withContext) to perform asynchronous operations. Such a case can be found below:</p> <pre><code>// This is a Bukkit example, but it works in the same way in every other framework.\n@EventHandler\nfun onPlayerJoinEvent(event: PlayerJoinEvent) {\nplugin.launch {\n// Main Thread\nval name = event.player.name\nval listOfFriends = withContext(Dispatchers.IO) {\n// IO Thread\nval friendNames = Files.readAllLines(Paths.get(\"$name.txt\"))\nfriendNames\n}\n\n// Main Thread\nval friendText = listOfFriends.joinToString(\", \")\nevent.player.sendMessage(\"My friends are: $friendText\")\n}\n}\n</code></pre>"},{"location":"coroutine/#plugin-launch-execution-order","title":"Plugin launch Execution order","text":"<p>If you use <code>plugin.launch</code>, it is important to understand the execution order.</p> <pre><code>// This is a Bukkit example, but it works in the same way in every other framework.\nclass Foo(private val plugin: Plugin) {\n\nfun bar() {\n// Main Thread\nprintln(\"I am first\")\n\nval job = plugin.launch {\nprintln(\"I am second\") // The context is not suspended when switching to the same suspendable context.\ndelay(1000)\nprintln(\"I am fourth\") // The context is given back after 1000 milliseconds and continuous here.\nbob()\n}\n\n// When calling delay the suspendable context is suspended and the original context immediately continuous here.\nprintln(\"I am third\")\n}\n\nprivate suspend fun bob() {\nprintln(\"I am fifth\")\n}\n}\n</code></pre> <pre><code>\"I am first\"\n\"I am second\"\n\"I am third\"\n\"I am fourth\"\n\"I am fifth\"\n</code></pre>"},{"location":"coroutine/#coroutines-everywhere","title":"Coroutines everywhere","text":"<p>Using <code>plugin.launch{}</code>is valuable if you migrate existing plugins to use coroutines. However, if you write a new plugin from scratch, you may consider using convenience integrations provided by MCCoroutine such as:</p> <ul> <li>Suspending Plugin</li> <li>Suspending Listeners</li> <li>Suspending CommandExecutors</li> </ul>"},{"location":"exception/","title":"Exception Handling","text":"<p>MCCoroutine implements exception handling as explained by the official Coroutine docs.</p> <p>If an exception is not caught (e.g. an exception is thrown in a suspendable commandexecutor or listener), the exception is propagated upwards to MCCoroutine.</p>"},{"location":"exception/#default-exception-behaviour","title":"Default Exception Behaviour","text":"<p>By default, MCCoroutine logs every exception except <code>CoroutineCancellation</code>, which is thrown when a job is cancelled.</p> <pre><code>logger.log(\nLevel.SEVERE,\n\"This is not an error of MCCoroutine! See sub exception for details.\",\nexception\n)\n</code></pre>"},{"location":"exception/#custom-exception-behaviour","title":"Custom Exception Behaviour","text":"<p>You can handle exceptions by yourself by listening to the <code>MCCoroutineExceptionEvent</code>. This event is sent to the event bus of the minecraft frame work (e.g. Bukkit, Sponge, BungeeCord)  and can be used for logging. The following points should be considered:</p> <ul> <li>The event arrives at the main thread (Bukkit, Sponge, Minestom)</li> <li>The event is also called for <code>CoroutineCancellation</code></li> <li>Exceptions arrive for every plugin using MCCoroutine. Check if <code>event.plugin</code> equals your plugin.</li> <li>You can cancel the event to disable logging the event with the default exception behaviour</li> <li>You can make this event a <code>suspend</code> function, however put a <code>try-catch</code> over the entire function. Otherwise, any   exception which occur while logging the original exception could stack indefinitely which eventually causes a <code>OutOfMemoryException</code></li> </ul>"},{"location":"faq/","title":"FAQ","text":"<p>This page explains the most common questions regarding MCCoroutine.</p>"},{"location":"faq/#how-is-mccoroutine-implemented","title":"How is MCCoroutine implemented?","text":"<p>MCCoroutine simply wraps the existing schedulers of the minecraft frameworks. For example, when you suspend a function using <code>withContext</code>, MCCoroutine sends new tasks to the Bukkit scheduler if necessary. Every consideration about Bukkit schedulers applies to MCCoroutine as well.</p>"},{"location":"faq/#does-mccoroutine-need-more-ram","title":"Does MCCoroutine need more RAM?","text":"<p>MCCoroutine does not create any resources like threads or threadPools. This means MCCoroutine does not have any overhead. However, Kotlin Coroutines  contains additional thread pools which may increase memory usage slightly. Take a look the the official Kotlin Coroutine docs for details.</p>"},{"location":"faq/#are-suspendable-listenerscommand-executors-slower","title":"Are Suspendable Listeners/Command Executors slower?","text":"<p>No, they are as fast as ordinary listeners and command executors. The registration of them is slightly slower because reflection calls are used to create them. Once players join the server and events arrive, they are the same speed.</p>"},{"location":"faq/#how-to-cancel-all-running-jobs","title":"How to cancel all running jobs?","text":"<p>You can control the behaviour of the coroutine using <code>plugin.scope</code>.</p> <pre><code>plugin.scope.coroutineContext.cancelChildren()\n</code></pre>"},{"location":"faq/#how-to-cancel-suspendable-events","title":"How to cancel suspendable events?","text":"<p>The following example is not possible. You cannot cancel events after you have suspended the context for the very first time. The event has already happened, and the outcome has already been decided.</p> <pre><code>@EventHandler\nsuspend fun onPlayerInteractEvent(event: PlayerInteractEvent) {\nwithContext(Dispatchers.IO){\n// e.g. read file/database\ndelay(50)\n}\n// Cancellation is not possible at this point.\nevent.isCancelled = true;\n}\n</code></pre> <p>Cancelling events before the first suspension is still possible.</p> <pre><code>@EventHandler\nsuspend fun onPlayerInteractEvent(event: PlayerInteractEvent) {\n// Cancellation is possible at this point.\nevent.isCancelled = true;\n\nwithContext(Dispatchers.IO){\n// e.g. read file/database\ndelay(50)\n}\n}\n</code></pre>"},{"location":"installation/","title":"Getting Started","text":"<p>In order to use the MCCoroutine Kotlin API, you need to include the following libraries into your project.</p>"},{"location":"installation/#add-mccoroutine-libraries","title":"Add MCCoroutine Libraries","text":"BukkitBungeeCordSpongeVelocityMinestom <pre><code>dependencies {\nimplementation(\"com.github.shynixn.mccoroutine:mccoroutine-bukkit-api:2.10.0\")\nimplementation(\"com.github.shynixn.mccoroutine:mccoroutine-bukkit-core:2.10.0\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation(\"com.github.shynixn.mccoroutine:mccoroutine-bungeecord-api:2.10.0\")\nimplementation(\"com.github.shynixn.mccoroutine:mccoroutine-bungeecord-core:2.10.0\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation(\"com.github.shynixn.mccoroutine:mccoroutine-sponge-api:2.10.0\")\nimplementation(\"com.github.shynixn.mccoroutine:mccoroutine-sponge-core:2.10.0\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation(\"com.github.shynixn.mccoroutine:mccoroutine-velocity-api:2.10.0\")\nimplementation(\"com.github.shynixn.mccoroutine:mccoroutine-velocity-core:2.10.0\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation(\"com.github.shynixn.mccoroutine:mccoroutine-minestom-api:2.10.0\")\nimplementation(\"com.github.shynixn.mccoroutine:mccoroutine-minestom-core:2.10.0\")\n}\n</code></pre>"},{"location":"installation/#add-kotlin-coroutines-libraries","title":"Add Kotlin Coroutines Libraries","text":"<p>MCCoroutine builds against Kotlin 1.3.x, however it does not distribute the Kotlin Runtime or Kotlin Coroutines Runtime. This means, you can use any Kotlin version in your plugins. It is even encouraged to always use the latest version.</p> <p>Replace 1.x.x with the actual versions. </p> <pre><code>dependencies {\nimplementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.x.x\")\n}\n</code></pre>"},{"location":"installation/#shade-dependencies","title":"Shade Dependencies","text":"Bukkit Server 1.17 - LatestOther Server <p>plugin.yml <pre><code>libraries:\n- com.github.shynixn.mccoroutine:mccoroutine-bukkit-api:2.10.0\n- com.github.shynixn.mccoroutine:mccoroutine-bukkit-core:2.10.0\n</code></pre></p> <p>Shade the libraries into your plugin.jar file using gradle or maven. </p>"},{"location":"installation/#test-the-plugin","title":"Test the Plugin","text":"<p>Try to call <code>launch{}</code> in your <code>onEnable()</code> function in your <code>Plugin</code> class.</p> <p>Further help</p> <p>Please take a look at the sample plugins (e.g. <code>mccoroutine-bukkit-sample</code> or <code>mccoroutine-sponge-sample</code>) which can be found on Github. A real production plugin using MCCoroutine can be found here.</p>"},{"location":"listener/","title":"Suspending Listeners","text":"<p>This page explains how you can use Kotlin Coroutines using the <code>suspend</code> key word for listeners in minecraft plugins.</p>"},{"location":"listener/#create-the-listener","title":"Create the Listener","text":"<p>Create a listener and add suspend to all functions where you perform suspendable operations (e.g. calling other suspendable functions). You can mix suspendable and non suspendable functions in listeners.</p> BukkitBungeeCordSpongeVelocityMinestom <pre><code>import org.bukkit.event.EventHandler\nimport org.bukkit.event.Listener\nimport org.bukkit.event.player.PlayerJoinEvent\nimport org.bukkit.event.player.PlayerQuitEvent\nimport java.util.*\n\nclass PlayerDataListener(private val database: Database) : Listener {\n@EventHandler\nsuspend fun onPlayerJoinEvent(event: PlayerJoinEvent) {\nval player = event.player\nval playerData = database.getDataFromPlayer(player)\nplayerData.name = player.name\nplayerData.lastJoinDate = Date()\ndatabase.saveData(player, playerData)\n}\n\n@EventHandler\nsuspend fun onPlayerQuitEvent(event: PlayerQuitEvent) {\nval player = event.player\nval playerData = database.getDataFromPlayer(player)\nplayerData.name = player.name\nplayerData.lastQuitDate = Date()\ndatabase.saveData(player, playerData)\n}\n}\n</code></pre> <p>In BungeeCord some events can be handled asynchronously. This allows full control over consuming, processing and resuming events when performing long running operations. When you create a suspend function using MCCoroutine, they automatically handle <code>registerIntent</code> and <code>completeIntent</code>. You do not have to do anything yourself, all suspend functions are automatically processed asynchronously.</p> <pre><code>import net.md_5.bungee.api.event.PostLoginEvent\nimport net.md_5.bungee.api.event.ServerDisconnectEvent\nimport net.md_5.bungee.api.plugin.Listener\nimport net.md_5.bungee.event.EventHandler\nimport java.util.*\n\nclass PlayerDataListener(private val database: Database) : Listener {\n@EventHandler\nsuspend fun onPlayerJoinEvent(event: PostLoginEvent) {\nval player = event.player\nval playerData = database.getDataFromPlayer(player)\nplayerData.name = player.name\nplayerData.lastJoinDate = Date()\ndatabase.saveData(player, playerData)\n}\n\n@EventHandler\nsuspend fun onPlayerQuitEvent(event: ServerDisconnectEvent) {\nval player = event.player\nval playerData = database.getDataFromPlayer(player)\nplayerData.name = player.name\nplayerData.lastQuitDate = Date()\ndatabase.saveData(player, playerData)\n}\n}\n</code></pre> <pre><code>import org.spongepowered.api.event.Listener\nimport org.spongepowered.api.event.network.ClientConnectionEvent\nimport java.util.*\n\nclass PlayerDataListener(private val database: Database) {\n@Listener\nsuspend fun onPlayerJoinEvent(event: ClientConnectionEvent.Join) {\nval player = event.targetEntity\nval playerData = database.getDataFromPlayer(player)\nplayerData.name = player.name\nplayerData.lastJoinDate = Date()\ndatabase.saveData(player, playerData)\n}\n\n@Listener\nsuspend fun onPlayerQuitEvent(event: ClientConnectionEvent.Disconnect) {\nval player = event.targetEntity\nval playerData = database.getDataFromPlayer(player)\nplayerData.name = player.name\nplayerData.lastQuitDate = Date()\ndatabase.saveData(player, playerData)\n}\n}\n</code></pre> <p>In Velocity events can be handled asynchronously. This allows full control over consuming, processing and resuming events when performing long running operations. When you create a suspend function using MCCoroutine, they automatically handle <code>Continuation</code> and <code>EventTask</code>. You do not have to do anything yourself, all suspend functions are automatically processed asynchronously.</p> <pre><code>import com.velocitypowered.api.event.Subscribe\nimport com.velocitypowered.api.event.connection.DisconnectEvent\nimport com.velocitypowered.api.event.connection.PostLoginEvent\nimport java.util.*\n\nclass PlayerDataListener(private val database: Database) {\n@Subscribe\nsuspend fun onPlayerJoinEvent(event: PostLoginEvent) {\nval player = event.player\nval playerData = database.getDataFromPlayer(player)\nplayerData.name = player.username\nplayerData.lastJoinDate = Date()\ndatabase.saveData(player, playerData)\n}\n\n@Subscribe\nsuspend fun onPlayerQuitEvent(event: DisconnectEvent) {\nval player = event.player\nval playerData = database.getDataFromPlayer(player)\nplayerData.name = player.username\nplayerData.lastQuitDate = Date()\ndatabase.saveData(player, playerData)\n}\n}\n</code></pre> <pre><code>import net.minestom.server.event.player.PlayerDisconnectEvent\nimport net.minestom.server.event.player.PlayerLoginEvent\nimport java.util.*\n\nclass PlayerDataListener(private val database: Database) {\nsuspend fun onPlayerJoinEvent(event: PlayerLoginEvent) {\nval player = event.player\nval playerData = database.getDataFromPlayer(player)\nplayerData.name = player.username\nplayerData.lastJoinDate = Date()\ndatabase.saveData(player, playerData)\n}\n\nsuspend fun onPlayerQuitEvent(event: PlayerDisconnectEvent) {\nval player = event.player\nval playerData = database.getDataFromPlayer(player)\nplayerData.name = player.username\nplayerData.lastQuitDate = Date()\ndatabase.saveData(player, playerData)\n}\n}\n</code></pre>"},{"location":"listener/#register-the-listener","title":"Register the Listener","text":"BukkitBungeeCordSpongeVelocityMinestom <p>Instead of using <code>registerEvents</code>, use the provided extension method <code>registerSuspendingEvents</code> to allow suspendable functions in your listener. Please notice, that timing measurements are no longer accurate for suspendable functions.</p> <pre><code>import com.github.shynixn.mccoroutine.bukkit.SuspendingJavaPlugin\nimport com.github.shynixn.mccoroutine.bukkit.registerSuspendingEvents\n\nclass MCCoroutineSamplePlugin : SuspendingJavaPlugin() {\nprivate val database = Database()\n\noverride suspend fun onEnableAsync() {\n// Minecraft Main Thread\ndatabase.createDbIfNotExist()\nserver.pluginManager.registerSuspendingEvents(PlayerDataListener(database), this)\n}\n\noverride suspend fun onDisableAsync() {\n// Minecraft Main Thread\n}\n}\n</code></pre> <p>Instead of using <code>registerListener</code>, use the provided extension method <code>registerSuspendingListener</code> to allow suspendable functions in your listener. Please notice, that timing measurements are no longer accurate for suspendable functions.</p> <pre><code>import com.github.shynixn.mccoroutine.bungeecord.SuspendingPlugin\nimport com.github.shynixn.mccoroutine.bungeecord.registerSuspendingListener\n\nclass MCCoroutineSamplePlugin : SuspendingPlugin() {\nprivate val database = Database()\n\noverride suspend fun onEnableAsync() {\n// BungeeCord Startup Thread\ndatabase.createDbIfNotExist()\nproxy.pluginManager.registerSuspendingListener(this, PlayerDataListener(database))\n}\n\noverride suspend fun onDisableAsync() {\n// BungeeCord Shutdown Thread (Not the same as the startup thread)\n}\n}\n</code></pre> <p>Instead of using <code>registerListeners</code>, use the provided extension method <code>registerSuspendingListeners</code> to allow suspendable functions in your listener. Please notice, that timing measurements are no longer accurate for suspendable functions.</p> <pre><code>import com.github.shynixn.mccoroutine.sponge.SuspendingPluginContainer\nimport com.github.shynixn.mccoroutine.sponge.registerSuspendingListeners\nimport com.google.inject.Inject\nimport org.spongepowered.api.Sponge\nimport org.spongepowered.api.event.Listener\nimport org.spongepowered.api.event.game.state.GameStartedServerEvent\nimport org.spongepowered.api.event.game.state.GameStoppingServerEvent\nimport org.spongepowered.api.plugin.Plugin\nimport org.spongepowered.api.plugin.PluginContainer\n\n@Plugin(\nid = \"mccoroutinesample\",\nname = \"MCCoroutineSample\",\ndescription = \"MCCoroutineSample is sample plugin to use MCCoroutine in Sponge.\"\n)\nclass MCCoroutineSamplePlugin {\nprivate val database = Database()\n@Inject\nprivate lateinit var suspendingPluginContainer: SuspendingPluginContainer\n@Inject\nprivate lateinit var pluginContainer : PluginContainer\n\n@Listener\nsuspend fun onEnable(event: GameStartedServerEvent) {\n// Minecraft Main Thread\ndatabase.createDbIfNotExist()\nSponge.getEventManager().registerSuspendingListeners(pluginContainer, PlayerDataListener(database))\n}\n\n@Listener\nsuspend fun onDisable(event: GameStoppingServerEvent) {\n// Minecraft Main Thread\n}\n}\n</code></pre> <p>Instead of using <code>register</code>, use the provided extension method <code>registerSuspend</code> to allow suspendable functions in your listener. Please notice, that timing measurements are no longer accurate for suspendable functions.</p> <pre><code>import com.github.shynixn.mccoroutine.velocity.SuspendingPluginContainer\nimport com.github.shynixn.mccoroutine.velocity.registerSuspend\nimport com.google.inject.Inject\nimport com.velocitypowered.api.event.Subscribe\nimport com.velocitypowered.api.event.proxy.ProxyInitializeEvent\nimport com.velocitypowered.api.plugin.Plugin\nimport com.velocitypowered.api.proxy.ProxyServer\n\n@Plugin(\nid = \"mccoroutinesample\",\nname = \"MCCoroutineSample\",\ndescription = \"MCCoroutineSample is sample plugin to use MCCoroutine in Velocity.\"\n)\nclass MCCoroutineSamplePlugin {\nprivate val database = Database()\n\n@Inject\nlateinit var proxyServer: ProxyServer\n\n@Inject\nconstructor(suspendingPluginContainer: SuspendingPluginContainer) {\nsuspendingPluginContainer.initialize(this)\n}\n\n@Subscribe\nsuspend fun onProxyInitialization(event: ProxyInitializeEvent) {\n// Velocity Thread Pool\ndatabase.createDbIfNotExist()\nproxyServer.eventManager.registerSuspend(this, PlayerDataListener(database))\n}\n}\n</code></pre> <p>Instead of using <code>addListener</code>, use the provided extension method <code>addSuspendingListener</code> to allow suspendable functions in your listener. Please notice, that timing measurements are no longer accurate for suspendable functions.</p> <pre><code>import com.github.shynixn.mccoroutine.minestom.addSuspendingListener\nimport com.github.shynixn.mccoroutine.minestom.launch\nimport com.github.shynixn.mccoroutine.minestom.sample.extension.impl.Database\nimport com.github.shynixn.mccoroutine.minestom.sample.extension.impl.PlayerDataListener\nimport net.minestom.server.MinecraftServer\nimport net.minestom.server.event.player.PlayerLoginEvent\n\nfun main(args: Array&lt;String&gt;) {\nval minecraftServer = MinecraftServer.init() minecraftServer.launch {\nval database = Database()\n// Minecraft Main Thread\ndatabase.createDbIfNotExist()\n\nval listener = PlayerDataListener(database)\nMinecraftServer.getGlobalEventHandler()\n.addSuspendingListener(minecraftServer, PlayerLoginEvent::class.java) { e -&gt;\nlistener.onPlayerJoinEvent(e)\n}\n}\n\nminecraftServer.start(\"0.0.0.0\", 25565)\n}\n</code></pre>"},{"location":"listener/#test-the-listener","title":"Test the Listener","text":"<p>Join and leave your server to observe <code>getDataFromPlayer</code> and <code>saveData</code> messages getting printed to your server log.</p>"},{"location":"plugin/","title":"Suspending Plugin","text":"<p>This guide explains how Kotlin Coroutines can be used in minecraft plugins in various ways using MCCoroutine. For this, a new plugin is developed from scratch to handle asynchronous and synchronous code.</p> <p>Important</p> <p>Make sure you have already installed MCCoroutine. See Installation for details.</p>"},{"location":"plugin/#plugin-main-class","title":"Plugin Main class","text":"<p>MCCoroutine does not need to be called explicitly in your plugin main class. It is started implicitly when you use it for the first time and disposed automatically when you reload your plugin.</p> BukkitBungeeCordSpongeVelocityMinestom <p>The first decision for Bukkit API based plugins is to decide between <code>JavaPlugin</code> or <code>SuspendingJavaPlugin</code>, which is a new base class extending <code>JavaPlugin</code>.</p> <p>If you want to perform async operations or call other suspending functions from your plugin class, go with the newly available type <code>SuspendingJavaPlugin</code> otherwise use <code>JavaPlugin</code>.</p> <pre><code>import com.github.shynixn.mccoroutine.bukkit.SuspendingJavaPlugin\n\nclass MCCoroutineSamplePlugin : SuspendingJavaPlugin() {\noverride suspend fun onEnableAsync() {\n// Minecraft Main Thread\n}\n\noverride suspend fun onDisableAsync() {\n// Minecraft Main Thread\n}\n}\n</code></pre> <p>How onEnableAsync works</p> <p>The implementation which calls the <code>onEnableAsync</code> function manipulates the Bukkit Server implementation in the following way: If a context switch is made, it blocks the entire minecraft main thread until the context is given back. This means, in this method, you can switch contexts as you like but the plugin is not considered enabled until the context is given back. It allows for a clean startup as the plugin is not considered \"enabled\" until the context is given back. Other plugins which are already enabled, may or may not already perform work in the background. Plugins, which may get enabled in the future, wait until this plugin is enabled.</p> <p>The first decision for BungeeCord API based plugins is to decide between <code>Plugin</code> or <code>SuspendingPlugin</code>, which is a new base class extending <code>Plugin</code>.</p> <p>If you want to perform async operations or call other suspending functions from your plugin class, go with the newly available type <code>SuspendingPlugin</code> otherwise use <code>Plugin</code>.</p> <pre><code>import com.github.shynixn.mccoroutine.bungeecord.SuspendingPlugin\n\nclass MCCoroutineSamplePlugin : SuspendingPlugin() {\noverride suspend fun onEnableAsync() {\n// BungeeCord Startup Thread\n}\n\noverride suspend fun onDisableAsync() {\n// BungeeCord Shutdown Thread (Not the same as the startup thread)\n}\n}\n</code></pre> <p>How onEnableAsync works</p> <p>The implementation which calls the <code>onEnableAsync</code> function manipulates the BungeeCord Server implementation in the following way: If a context switch is made, it blocks the entire bungeecord startup thread until the context is given back. This means, in this method, you can switch contexts as you like but the plugin is not considered enabled until the context is given back. It allows for a clean startup as the plugin is not considered \"enabled\" until the context is given back. Other plugins which are already enabled, may or may not already perform work in the background. Plugins, which may get enabled in the future, wait until this plugin is enabled.</p> <p>The first decision for Sponge API based plugins is to decide, if you want to call other suspending functions from your plugin class. If so, add a field which injects the type <code>SuspendingPluginContainer</code>. This turns your main class into a suspendable listener.</p> <pre><code>import com.github.shynixn.mccoroutine.sponge.SuspendingPluginContainer\n@Plugin(\nid = \"mccoroutinesample\",\nname = \"MCCoroutineSample\",\ndescription = \"MCCoroutineSample is sample plugin to use MCCoroutine in Sponge.\"\n)\nclass MCCoroutineSamplePlugin {\n@Inject\nprivate lateinit var suspendingPluginContainer: SuspendingPluginContainer\n\n@Listener\nsuspend fun onEnable(event: GameStartedServerEvent) {\n// Minecraft Main Thread\n}\n\n@Listener\nsuspend fun onDisable(event: GameStoppingServerEvent) {\n// Minecraft Main Thread\n}\n}\n</code></pre> <p>MCCoroutine requires to initialize the plugin coroutine scope manually in your plugin main class. This  also allows to call suspending functions in your plugin main class.</p> <pre><code>import com.github.shynixn.mccoroutine.velocity.SuspendingPluginContainer\n@Plugin(\nid = \"mccoroutinesample\",\nname = \"MCCoroutineSample\",\ndescription = \"MCCoroutineSample is sample plugin to use MCCoroutine in Velocity.\"\n)\nclass MCCoroutineSamplePlugin {\n@Inject\nconstructor(suspendingPluginContainer: SuspendingPluginContainer) {\nsuspendingPluginContainer.initialize(this)\n}\n\n@Subscribe\nsuspend fun onProxyInitialization(event: ProxyInitializeEvent) {\n// Velocity Thread Pool\n}\n}\n</code></pre> <p>MCCoroutine can be used on server or on extension level. The example below shows using MCCoroutine on server level. If you are developing an extension, you can use the instance of your <code>Extension</code> instead of the <code>MinecraftServer</code></p> <pre><code>import com.github.shynixn.mccoroutine.minestom.launch\nimport net.minestom.server.MinecraftServer\n\nfun main(args: Array&lt;String&gt;) {\nval minecraftServer = MinecraftServer.init() minecraftServer.launch {\n// Suspendable operations   \n}\nminecraftServer.start(\"0.0.0.0\", 25565)\n}\n</code></pre>"},{"location":"plugin/#calling-a-database-from-plugin-main-class","title":"Calling a Database from Plugin Main class","text":"<p>Create a class containing properties of data, which we want to store into a database.</p> <pre><code>class PlayerData(var uuid: UUID, var name: String, var lastJoinDate: Date, var lastQuitDate: Date) {\n}\n</code></pre> <p>Create a class <code>Database</code>, which is responsible to store/retrieve this data into/from a database. Here, it is important that we perform all IO calls on async threads and returns on the minecraft main thread.</p> BukkitBungeeCordSpongeVelocityMinestom <pre><code>import kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\nimport org.bukkit.entity.Player\nimport java.util.*\n\nclass Database() {\nsuspend fun createDbIfNotExist() {\nprintln(\"[createDbIfNotExist] Start on minecraft thread \" + Thread.currentThread().id)\nwithContext(Dispatchers.IO){\nprintln(\"[createDbIfNotExist] Creating database on database io thread \" + Thread.currentThread().id)\n// ... create tables\n}\nprintln(\"[createDbIfNotExist] End on minecraft thread \" + Thread.currentThread().id)\n}\n\nsuspend fun getDataFromPlayer(player : Player) : PlayerData {\nprintln(\"[getDataFromPlayer] Start on minecraft thread \" + Thread.currentThread().id)\nval playerData = withContext(Dispatchers.IO) {\nprintln(\"[getDataFromPlayer] Retrieving player data on database io thread \" + Thread.currentThread().id)\n// ... get from database by player uuid or create new playerData instance.\nPlayerData(player.uniqueId, player.name, Date(), Date())\n}\n\nprintln(\"[getDataFromPlayer] End on minecraft thread \" + Thread.currentThread().id)\nreturn playerData;\n}\n\nsuspend fun saveData(player : Player, playerData : PlayerData) {\nprintln(\"[saveData] Start on minecraft thread \" + Thread.currentThread().id)\n\nwithContext(Dispatchers.IO){\nprintln(\"[saveData] Saving player data on database io thread \" + Thread.currentThread().id)\n// insert or update playerData\n}\n\nprintln(\"[saveData] End on minecraft thread \" + Thread.currentThread().id)\n}\n}\n</code></pre> <p>Important</p> <p>BungeeCord does not have a main thread or minecraft thread. Instead it operates on different types of thread pools. This means, the thread id is not always the same if we suspend an operation. Therefore, it is recommend to print the name of the thread instead of the id to see which threadpool you are currently on.</p> <pre><code>import kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\nimport net.md_5.bungee.api.connection.ProxiedPlayer\nimport java.util.*\n\nclass Database() {\nsuspend fun createDbIfNotExist() {\nprintln(\"[createDbIfNotExist] Start on any thread \" + Thread.currentThread().name)\nwithContext(Dispatchers.IO){\nprintln(\"[createDbIfNotExist] Creating database on database io thread \" + Thread.currentThread().name)\n// ... create tables\n}\nprintln(\"[createDbIfNotExist] End on bungeecord plugin threadpool \" + Thread.currentThread().name)\n}   suspend fun getDataFromPlayer(player : ProxiedPlayer) : PlayerData {\nprintln(\"[getDataFromPlayer] Start on any thread \" + Thread.currentThread().name)\nval playerData = withContext(Dispatchers.IO) {\nprintln(\"[getDataFromPlayer] Retrieving player data on database io thread \" + Thread.currentThread().name)\n// ... get from database by player uuid or create new playerData instance.\nPlayerData(player.uniqueId, player.name, Date(), Date())\n}\n\nprintln(\"[getDataFromPlayer] End on bungeecord plugin threadpool \" + Thread.currentThread().name)\nreturn playerData;\n}\n\nsuspend fun saveData(player : ProxiedPlayer, playerData : PlayerData) {\nprintln(\"[saveData] Start on any thread \" + Thread.currentThread().name)\n\nwithContext(Dispatchers.IO){\nprintln(\"[saveData] Saving player data on database io thread \" + Thread.currentThread().name)\n// insert or update playerData\n}\n\nprintln(\"[saveData] End on bungeecord plugin threadpool \" + Thread.currentThread().name)\n}\n}\n</code></pre> <pre><code>import kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\nimport org.spongepowered.api.entity.living.player.Player\nimport java.util.*\n\nclass Database() {\nsuspend fun createDbIfNotExist() {\nprintln(\"[createDbIfNotExist] Start on minecraft thread \" + Thread.currentThread().id)\nwithContext(Dispatchers.IO){\nprintln(\"[createDbIfNotExist] Creating database on database io thread \" + Thread.currentThread().id)\n// ... create tables\n}\nprintln(\"[createDbIfNotExist] End on minecraft thread \" + Thread.currentThread().id)\n}\n\nsuspend fun getDataFromPlayer(player : Player) : PlayerData {\nprintln(\"[getDataFromPlayer] Start on minecraft thread \" + Thread.currentThread().id)\nval playerData = withContext(Dispatchers.IO) {\nprintln(\"[getDataFromPlayer] Retrieving player data on database io thread \" + Thread.currentThread().id)\n// ... get from database by player uuid or create new playerData instance.\nPlayerData(player.uniqueId, player.name, Date(), Date())\n}\n\nprintln(\"[getDataFromPlayer] End on minecraft thread \" + Thread.currentThread().id)\nreturn playerData;\n}\n\nsuspend fun saveData(player : Player, playerData : PlayerData) {\nprintln(\"[saveData] Start on minecraft thread \" + Thread.currentThread().id)\n\nwithContext(Dispatchers.IO){\nprintln(\"[saveData] Saving player data on database io thread \" + Thread.currentThread().id)\n// insert or update playerData\n}\n\nprintln(\"[saveData] End on minecraft thread \" + Thread.currentThread().id)\n}\n}\n</code></pre> <p>Important</p> <p>Velocity does not have a main thread or minecraft thread. Instead it operates on different types of thread pools. This means, the thread id is not always the same if we suspend an operation. Therefore, it is recommend to print the name of the thread instead of the id to see which threadpool you are currently on.</p> <pre><code>import com.velocitypowered.api.proxy.Player\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\nimport java.util.*\n\nclass Database() {\nsuspend fun createDbIfNotExist() {\nprintln(\"[createDbIfNotExist] Start on any thread \" + Thread.currentThread().name)\nwithContext(Dispatchers.IO) {\nprintln(\"[createDbIfNotExist] Creating database on database io thread \" + Thread.currentThread().name)\n// ... create tables\n}\nprintln(\"[createDbIfNotExist] End on velocity plugin threadpool \" + Thread.currentThread().name)\n}\n\nsuspend fun getDataFromPlayer(player: Player): PlayerData {\nprintln(\"[getDataFromPlayer] Start on any thread \" + Thread.currentThread().name)\nval playerData = withContext(Dispatchers.IO) {\nprintln(\"[getDataFromPlayer] Retrieving player data on database io thread \" + Thread.currentThread().name)\n// ... get from database by player uuid or create new playerData instance.\nPlayerData(player.uniqueId, player.username, Date(), Date())\n}\n\nprintln(\"[getDataFromPlayer] End on velocity plugin threadpool \" + Thread.currentThread().name)\nreturn playerData;\n}\n\nsuspend fun saveData(player: Player, playerData: PlayerData) {\nprintln(\"[saveData] Start on any thread \" + Thread.currentThread().name)\n\nwithContext(Dispatchers.IO) {\nprintln(\"[saveData] Saving player data on database io thread \" + Thread.currentThread().name)\n// insert or update playerData\n}\n\nprintln(\"[saveData] End on velocity plugin threadpool \" + Thread.currentThread().name)\n}\n}\n</code></pre> <pre><code>import kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\nimport net.minestom.server.entity.Player\nimport java.util.*\n\nclass Database() {\nsuspend fun createDbIfNotExist() {\nprintln(\"[createDbIfNotExist] Start on minecraft thread \" + Thread.currentThread().id)\nwithContext(Dispatchers.IO){\nprintln(\"[createDbIfNotExist] Creating database on database io thread \" + Thread.currentThread().id)\n// ... create tables\n}\nprintln(\"[createDbIfNotExist] End on minecraft thread \" + Thread.currentThread().id)\n}\n\nsuspend fun getDataFromPlayer(player : Player) : PlayerData {\nprintln(\"[getDataFromPlayer] Start on minecraft thread \" + Thread.currentThread().id)\nval playerData = withContext(Dispatchers.IO) {\nprintln(\"[getDataFromPlayer] Retrieving player data on database io thread \" + Thread.currentThread().id)\n// ... get from database by player uuid or create new playerData instance.\nPlayerData(player.uuid, player.username, Date(), Date())\n}\n\nprintln(\"[getDataFromPlayer] End on minecraft thread \" + Thread.currentThread().id)\nreturn playerData;\n}\n\nsuspend fun saveData(player : Player, playerData : PlayerData) {\nprintln(\"[saveData] Start on minecraft thread \" + Thread.currentThread().id)\n\nwithContext(Dispatchers.IO){\nprintln(\"[saveData] Saving player data on database io thread \" + Thread.currentThread().id)\n// insert or update playerData\n}\n\nprintln(\"[saveData] End on minecraft thread \" + Thread.currentThread().id)\n}\n}\n</code></pre> <p>Create a new instance of the database and call it in your main class.</p> BukkitBungeeCordSpongeVelocityMinestom <pre><code>import com.github.shynixn.mccoroutine.bukkit.SuspendingJavaPlugin\n\nclass MCCoroutineSamplePlugin : SuspendingJavaPlugin() {\nprivate val database = Database()\n\noverride suspend fun onEnableAsync() {\n// Minecraft Main Thread\ndatabase.createDbIfNotExist()\n}\n\noverride suspend fun onDisableAsync() {\n}\n}\n</code></pre> <pre><code>import com.github.shynixn.mccoroutine.bungeecord.SuspendingPlugin\n\nclass MCCoroutineSamplePlugin : SuspendingPlugin() {\nprivate val database = Database()\n\noverride suspend fun onEnableAsync() {\n// BungeeCord Startup Thread\ndatabase.createDbIfNotExist()\n}\n\noverride suspend fun onDisableAsync() {\n// BungeeCord Shutdown Thread (Not the same as the startup thread)\n}\n}\n</code></pre> <pre><code>import com.github.shynixn.mccoroutine.sponge.SuspendingPluginContainer\n@Plugin(\nid = \"mccoroutinesample\",\nname = \"MCCoroutineSample\",\ndescription = \"MCCoroutineSample is sample plugin to use MCCoroutine in Sponge.\"\n)\nclass MCCoroutineSamplePlugin {\nprivate val database = Database()\n@Inject\nprivate lateinit var suspendingPluginContainer: SuspendingPluginContainer\n\n@Listener\nsuspend fun onEnable(event: GameStartedServerEvent) {\n// Minecraft Main Thread\ndatabase.createDbIfNotExist()\n}\n\n@Listener\nsuspend fun onDisable(event: GameStoppingServerEvent) {\n// Minecraft Main Thread\n}\n}\n</code></pre> <p>MCCoroutine requires to initialize the plugin coroutine scope manually in your plugin main class. This  also allows to call suspending functions in your plugin main class.</p> <pre><code>import com.github.shynixn.mccoroutine.velocity.SuspendingPluginContainer\n@Plugin(\nid = \"mccoroutinesample\",\nname = \"MCCoroutineSample\",\ndescription = \"MCCoroutineSample is sample plugin to use MCCoroutine in Velocity.\"\n)\nclass MCCoroutineSamplePlugin {\nprivate val database = Database()\n\n@Inject\nconstructor(suspendingPluginContainer: SuspendingPluginContainer) {\nsuspendingPluginContainer.initialize(this)\n}\n\n@Subscribe\nsuspend fun onProxyInitialization(event: ProxyInitializeEvent) {\n// Velocity Thread Pool\ndatabase.createDbIfNotExist()\n}\n}\n</code></pre> <pre><code>import com.github.shynixn.mccoroutine.minestom.launch\nimport net.minestom.server.MinecraftServer\n\nfun main(args: Array&lt;String&gt;) {\nval minecraftServer = MinecraftServer.init() minecraftServer.launch {\n// Minecraft Main Thread\nval database = Database()\ndatabase.createDbIfNotExist()\n}\nminecraftServer.start(\"0.0.0.0\", 25565)\n}\n</code></pre>"},{"location":"plugin/#test-the-plugin","title":"Test the Plugin","text":"<p>Start your server to observe the <code>createDbIfNotExist</code> messages getting printed to your server log. Extend it with real database operations to get familiar with how it works.</p>"},{"location":"plugindisable/","title":"Coroutines in onDisable","text":"<p>(This site is only relevant for Spigot, CraftBukkit and Paper)</p> <p>After moving most of your code to suspend functions, you may want to launch a coroutine in the <code>onDisable</code> or any other function, which gets called, after the plugin has already been disabled.</p>"},{"location":"plugindisable/#default-behaviour-shutdownstrategyscheduler","title":"Default Behaviour (ShutdownStrategy=Scheduler)","text":"<p>The default behaviour of MCCoroutine is to stop all coroutines immediately, once the <code>BukkitScheduler</code> has been shutdown. This happens automatically and before your <code>onDisable</code> function of your <code>JavaPlugin</code> class gets called.</p> <p>If you try the following, you run into the following exception.</p> <pre><code>override fun onDisable() {\nprintln(\"[onDisable] Is starting on Thread:${Thread.currentThread().name}/${Thread.currentThread().id}/primaryThread=${Bukkit.isPrimaryThread()}\")\nval plugin = this\n\nplugin.launch {\nprintln(\"[onDisable] Simulating data save on Thread:${Thread.currentThread().name}/${Thread.currentThread().id}/primaryThread=${Bukkit.isPrimaryThread()}\")\nThread.sleep(500)\n}\n\nprintln(\"[onDisable] Is ending on Thread:${Thread.currentThread().name}/${Thread.currentThread().id}/primaryThread=${Bukkit.isPrimaryThread()}\")\n}\n</code></pre> <pre><code>java.lang.RuntimeException: Plugin MCCoroutine-Sample attempted to start a new coroutine session while being disabled.\n</code></pre> <p>This behaviour makes sense, because the BukkitScheduler works in the same way. MCCoroutine is just a smart wrapper for it.</p>"},{"location":"plugindisable/#calling-a-suspend-function","title":"Calling a suspend function","text":"<p>However, you may have to call a suspend function anyway. This one of the few exceptions were using <code>runBlocking</code> makes sense:</p> <pre><code>override fun onDisable() {\nprintln(\"[onDisable] Is starting on Thread:${Thread.currentThread().name}/${Thread.currentThread().id}/primaryThread=${Bukkit.isPrimaryThread()}\")\nval plugin = this\n\nrunBlocking {\nfoo()\n}\n\nprintln(\"[onDisable] Is ending on Thread:${Thread.currentThread().name}/${Thread.currentThread().id}/primaryThread=${Bukkit.isPrimaryThread()}\")\n}\n\nsuspend fun foo() {\nprintln(\"[onDisable] Simulating data save on Thread:${Thread.currentThread().name}/${Thread.currentThread().id}/primaryThread=${Bukkit.isPrimaryThread()}\")\nThread.sleep(500)\n}\n</code></pre>"},{"location":"plugindisable/#manual-behaviour-shutdownstrategymanual","title":"Manual Behaviour (ShutdownStrategy=Manual)","text":"<p>The default strategy is the recommend one and you should design your plugin according that.</p> <p>However, there may be edge cases, where you need full control over handling remaining coroutine jobs and use <code>minecraftDispatcher</code> or <code>asyncDispatcher</code> after the plugin has been disabled.</p> <p>Change the shutdownStrategy in <code>onEnable</code></p> <pre><code>override fun onEnable() {\nval plugin = this\nplugin.mcCoroutineConfiguration.shutdownStrategy = ShutdownStrategy.MANUAL\n\n// Your code ...\n}\n</code></pre> <p>Call <code>disposePluginSession</code> after you are finished.</p> <pre><code>override fun onDisable() {\n// Your code ...\n\nval plugin = this\nplugin.mcCoroutineConfiguration.disposePluginSession()\n}\n</code></pre>"},{"location":"plugindisable/#pluginlaunch-is-back","title":"Plugin.launch is back","text":"<p>This allows to use <code>plugin.launch</code> in your <code>onDisable</code> function.</p> <pre><code>override fun onDisable() {\nval plugin = this\nprintln(\"[MCCoroutineSamplePlugin/onDisableAsync] Is starting on Thread:${Thread.currentThread().name}/${Thread.currentThread().id}/primaryThread=${Bukkit.isPrimaryThread()}\")\n\nplugin.launch {\nprintln(\"[MCCoroutineSamplePlugin/onDisableAsync] Number 1:${Thread.currentThread().name}/${Thread.currentThread().id}/primaryThread=${Bukkit.isPrimaryThread()}\")\ndelay(500)\nprintln(\"[MCCoroutineSamplePlugin/onDisableAsync] Number 2:${Thread.currentThread().name}/${Thread.currentThread().id}/primaryThread=${Bukkit.isPrimaryThread()}\")\n}\n\nplugin.mcCoroutineConfiguration.disposePluginSession()\nprintln(\"[MCCoroutineSamplePlugin/onDisableAsync] Is ending on Thread:${Thread.currentThread().name}/${Thread.currentThread().id}/primaryThread=${Bukkit.isPrimaryThread()}\")\n}\n</code></pre> <pre><code>[Server thread/INFO]: [MCCoroutine-Sample] Disabling MCCoroutine-Sample\n[Server thread/INFO]: [MCCoroutineSamplePlugin/onDisableAsync] Is starting on Thread:Server thread/55/primaryThread=true\n[Server thread/INFO]: [MCCoroutineSamplePlugin/onDisableAsync] Number 1:Server thread/55/primaryThread=true\n[Server thread/INFO]: [MCCoroutineSamplePlugin/onDisableAsync] Is ending on Thread:Server thread/55/primaryThread=true\n</code></pre> <p>However, the message <code>[MCCoroutineSamplePlugin/onDisableAsync] Number 2</code> will not printed, because <code>plugin.mcCoroutineConfiguration.disposePluginSession()</code> is called first (context switch of delay).</p> <p>This means, we need to use <code>runBlocking</code> anyway:</p> <pre><code>override fun onDisable() {\nval plugin = this\nprintln(\"[MCCoroutineSamplePlugin/onDisableAsync] Is starting on Thread:${Thread.currentThread().name}/${Thread.currentThread().id}/primaryThread=${Bukkit.isPrimaryThread()}\")\n\nrunBlocking {\nplugin.launch {\nprintln(\"[MCCoroutineSamplePlugin/onDisableAsync] Number 1:${Thread.currentThread().name}/${Thread.currentThread().id}/primaryThread=${Bukkit.isPrimaryThread()}\")\ndelay(500)\nprintln(\"[MCCoroutineSamplePlugin/onDisableAsync] Number 2:${Thread.currentThread().name}/${Thread.currentThread().id}/primaryThread=${Bukkit.isPrimaryThread()}\")\n}.join()\n}\n\nplugin.mcCoroutineConfiguration.disposePluginSession()\nprintln(\"[MCCoroutineSamplePlugin/onDisableAsync] Is ending on Thread:${Thread.currentThread().name}/${Thread.currentThread().id}/primaryThread=${Bukkit.isPrimaryThread()}\")\n}\n</code></pre> <pre><code>[Server thread/INFO]: [MCCoroutine-Sample] Disabling MCCoroutine-Sample\n[Server thread/INFO]: [MCCoroutineSamplePlugin/onDisableAsync] Is starting on Thread:Server thread/55/primaryThread=true\n[Server thread/INFO]: [MCCoroutineSamplePlugin/onDisableAsync] Number 1:Server thread/55/primaryThread=true\n[kotlinx.coroutines.DefaultExecutor/INFO]: [MCCoroutineSamplePlugin/onDisableAsync] Number 2:kotlinx.coroutines.DefaultExecutor/133/primaryThread=false\n[Server thread/INFO]: [MCCoroutineSamplePlugin/onDisableAsync] Is ending on Thread:Server thread/55/primaryThread=true\n</code></pre> <p>This helps, however it is important to notice that the thread executing <code>MCCoroutineSamplePlugin/onDisableAsync] Number 2</code> is no longer the primary thread even though we are using the <code>plugin.launch</code> scope, which should guarantee this. After the <code>BukkitScheduler</code> has been shutdown, MCCoroutine is no longer able to guarantee any context switches. Depending on your use case, you may or may not care about that.</p> <p>Therefore, think twice if you really want to have so much control. You are on your own, if you set the shutdownStrategy to manual.</p>"},{"location":"plugindisable/#waiting-for-jobs-to-complete","title":"Waiting for jobs to complete","text":"<p>One useful case, where you want to set the shutdownStrategy to manual is to be able to wait for long running jobs to complete before you disable the plugin.</p> <pre><code>private var longRunningJob: Job? = null\n\noverride fun onEnable() {\nval plugin = this\nplugin.mcCoroutineConfiguration.shutdownStrategy = ShutdownStrategy.MANUAL\n\nlongRunningJob = plugin.launch {\ndelay(10000)\nprintln(\"Over\")\n}\n}\n\noverride fun onDisable() {\nrunBlocking {\nlongRunningJob!!.join()\n}\n\nval plugin = this\nplugin.mcCoroutineConfiguration.disposePluginSession()\n}\n</code></pre> <pre><code>[Server thread/INFO]: [MCCoroutine-Sample] Disabling MCCoroutine-Sample\n[kotlinx.coroutines.DefaultExecutor/INFO]: Over\n</code></pre>"},{"location":"plugindisable/#waiting-for-all-jobs-to-complete","title":"Waiting for all jobs to complete","text":"<p>You can also wait for all of your spawned open jobs to complete.</p> <pre><code>override fun onEnable() {\nval plugin = this\nplugin.mcCoroutineConfiguration.shutdownStrategy = ShutdownStrategy.MANUAL\n\nplugin.launch {\ndelay(10000)\nprintln(\"Over\")\n}\n}\n\noverride fun onDisable() {\nval plugin = this\n\nrunBlocking {\nplugin.scope.coroutineContext[Job]!!.children.forEach { childJob -&gt;\nchildJob.join()\n}\n}\n\nplugin.mcCoroutineConfiguration.disposePluginSession()\n}\n</code></pre> <pre><code>[Server thread/INFO]: [MCCoroutine-Sample] Disabling MCCoroutine-Sample\n[kotlinx.coroutines.DefaultExecutor/INFO]: Over\n</code></pre>"},{"location":"tasks/","title":"Suspending Delayed, Repeating Tasks","text":"<p>This page explains how you can delay and repeat tasks using Kotlin Coroutines.</p>"},{"location":"tasks/#delaying-tasks","title":"Delaying tasks","text":"<p>If you are already in a <code>suspend</code> function, you can simply use <code>delay</code> to delay an execution.</p> <p>Using <code>delay</code> we can delay the current context (e.g. Main Thread) by some milliseconds, to easily delay actions without blocking the server. <code>delay</code> essentially suspends the current context and continuous after the given time.</p> <p>Difference between delay() and Thread.sleep()</p> <p>There is a big difference with <code>delay()</code> and <code>Thread.sleep()</code>. Consult the official Kotlin Coroutines documentation for details, however essentially <code>Thread.sleep()</code> blocks the thread for a given time and <code>delay()</code> suspends the thread for a given time. When a thread is suspended, it can do other work (e.g. server handles other operations like players joining or commands) compared to when a thread is blocked, it cannot do other work (e.g.  server appears frozen).</p> <pre><code>suspend fun sayHello() {\nprintln(\"Please say hello in 2 seconds\")\ndelay(2000) // Delay for 2000 milliseconds\nprintln(\"hello\")\n}\n</code></pre> <p>If you are not in a <code>suspend</code> function, use <code>plugin.launch</code> together with <code>delay</code>.</p> <pre><code>fun sayHello() {\nplugin.launch {\nprintln(\"Please say hello in 2 seconds\")\ndelay(2000) // Delay for 2000 milliseconds\nprintln(\"hello\")\n}\n}\n</code></pre>"},{"location":"tasks/#delay-ticks","title":"Delay Ticks","text":"<p>MCCoroutine offers an extension method to use delay together with Bukkit and Sponge ticks.</p> <pre><code>delay(1.ticks)\n</code></pre> <p>Prefer using <code>delay(1.ticks)</code> when delaying on the minecraft main thread instead of <code>delay(50)</code>. The tick extension function is more accurate than using milliseconds directly. The technical details are explained in this github issue.</p>"},{"location":"tasks/#repeating-tasks","title":"Repeating tasks","text":"<p>If you are already in a <code>suspend</code> function, you can simply use traditional loops with <code>delay</code> to repeat tasks.</p> <pre><code>suspend fun sayHello() {\nprintln(\"Please say hello 10 times every 2 seconds\")\n\nfor (i in 0 until 10) {\ndelay(2000) // Delay for 2000 milliseconds\nprintln(\"hello\")\n}\n}\n</code></pre> <p>If you are not in a <code>suspend</code> function, use <code>plugin.launch</code> together with <code>delay</code>.</p> <pre><code>fun sayHello() {\nplugin.launch {\nprintln(\"Please say hello 10 times every 2 seconds\")\n\nfor (i in 0 until 10) {\ndelay(2000) // Delay for 2000 milliseconds\nprintln(\"hello\")\n}\n}\n}\n</code></pre>"},{"location":"tasks/#creating-a-minigame-using-delay-bukkit","title":"Creating a Minigame using delay (Bukkit)","text":"<p>One example where <code>delay</code> is really useful is when creating minigames. It makes the contract of minigame classes very easy to understand. Let's start by implementing a basic minigame class.</p> <p>The first example shows a countdown in the start function of the minigame.</p> <pre><code>import kotlinx.coroutines.delay\nimport org.bukkit.entity.Player\n\nclass MiniGame {\nprivate var isStarted = false;\nprivate var players = HashSet&lt;Player&gt;()\n\nfun join(player: Player) {\nif (isStarted) {\nreturn\n}\n\nplayers.add(player)\n}\n\nsuspend fun start() {\nif (isStarted) {\nreturn\n}\n\nisStarted = true\n\n// This loop represents a traditional repeating task which ticks every 1 second and is called 20 times.\nfor (i in 0 until 20) {\nsendMessageToPlayers(\"Game is starting in ${20 - i} seconds.\")\ndelay(1000)\n}\n\n// ... Teleport players to game.\n}\n\nprivate fun sendMessageToPlayers(message: String) {\nplayers.forEach { p -&gt; p.sendMessage(message) }\n}\n}\n</code></pre>"},{"location":"tasks/#add-a-run-function-to-the-minigame-class","title":"Add a run function to the MiniGame class","text":"<p>We can extend the start method to call <code>run</code> which contains a loop to tick the miniGame every 1 second.</p> <pre><code>import kotlinx.coroutines.delay\nimport org.bukkit.entity.Player\n\nclass MiniGame {\nprivate var isStarted = false;\nprivate var players = HashSet&lt;Player&gt;()\nprivate var remainingTime = 0\n\n//...\n\nsuspend fun start() {\nif (isStarted) {\nreturn\n}\n\nisStarted = true\n\n// This loop represents a traditional repeating task which ticks every 1 second and is called 20 times.\nfor (i in 0 until 20) {\nsendMessageToPlayers(\"Game is starting in ${20 - i} seconds.\")\ndelay(1000)\n}\n\n// ... Teleport players to game.\nrun()\n}\n\nprivate suspend fun run() {\nremainingTime = 300 // 300 seconds\n\nwhile (isStarted &amp;&amp; remainingTime &gt; 0) {\nsendMessageToPlayers(\"Game is over in ${remainingTime} seconds.\")\ndelay(1000)\nremainingTime--\n}\n}\n\n//...\n}\n</code></pre>"},{"location":"tasks/#add-a-function-to-stop-the-game","title":"Add a function to stop the game.","text":"<p>An admin should be able to cancel the minigame, which we can implement by a <code>stop</code> function.</p> <pre><code>import kotlinx.coroutines.delay\nimport org.bukkit.entity.Player\n\nclass MiniGame {\nprivate var isStarted = false;\nprivate var players = HashSet&lt;Player&gt;()\nprivate var remainingTime = 0\n\n//...\n\nprivate suspend fun run() {\nremainingTime = 300 // 300 seconds\n\nwhile (isStarted &amp;&amp; remainingTime &gt; 0) {\nsendMessageToPlayers(\"Game is over in ${remainingTime} seconds.\")\ndelay(1000)\nremainingTime--\n}\n\nif (!isStarted) {\nsendMessageToPlayers(\"Game was cancelled by external stop.\")\n}\n\nisStarted = false\n// ... Teleport players back to lobby.\n}\n\nfun stop() {\nif (!isStarted) {\nreturn\n}\n\nisStarted = false\n}\n\n//...\n}\n</code></pre>"},{"location":"tasks/#the-full-minigame-class","title":"The full MiniGame class:","text":"<pre><code>import kotlinx.coroutines.delay\nimport org.bukkit.entity.Player\n\nclass MiniGame {\nprivate var isStarted = false;\nprivate var players = HashSet&lt;Player&gt;()\nprivate var remainingTime = 0\n\nfun join(player: Player) {\nif (isStarted) {\nreturn\n}\n\nplayers.add(player)\n}\n\nsuspend fun start() {\nif (isStarted) {\nreturn\n}\n\nisStarted = true\n\n// This loop represents a traditional repeating task which ticks every 1 second and is called 20 times.\nfor (i in 0 until 20) {\nsendMessageToPlayers(\"Game is starting in ${20 - i} seconds.\")\ndelay(1000)\n}\n\n// ... Teleport players to game.\nrun()\n}\n\nprivate suspend fun run() {\nremainingTime = 300 // 300 seconds\n\nwhile (isStarted &amp;&amp; remainingTime &gt; 0) {\nsendMessageToPlayers(\"Game is over in ${remainingTime} seconds.\")\ndelay(1000)\nremainingTime--\n}\n\nif (!isStarted) {\nsendMessageToPlayers(\"Game was cancelled by external stop.\")\n}\n\nisStarted = false\n// ... Teleport players back to lobby.\n}\n\nfun stop() {\nif (!isStarted) {\nreturn\n}\n\nisStarted = false\n}\n\nprivate fun sendMessageToPlayers(message: String) {\nplayers.forEach { p -&gt; p.sendMessage(message) }\n}\n}\n</code></pre>"},{"location":"tasks/#connect-javaplugin-listener-and-minigame","title":"Connect JavaPlugin, Listener and MiniGame","text":"<pre><code>import org.bukkit.event.EventHandler\nimport org.bukkit.event.Listener\nimport org.bukkit.event.player.PlayerJoinEvent\n\nclass MiniGameListener(private val miniGame: MiniGame) : Listener {\n@EventHandler\nsuspend fun onPlayerJoinEvent(playerJoinEvent: PlayerJoinEvent) {\nminiGame.join(playerJoinEvent.player)\n\n// Just for testing purposes\nminiGame.start()\n}\n}\n</code></pre> <pre><code>import com.github.shynixn.mccoroutine.bukkit.SuspendingJavaPlugin\nimport com.github.shynixn.mccoroutine.bukkit.registerSuspendingEvents\nimport com.github.shynixn.mccoroutine.bukkit.setSuspendingExecutor\n\nclass MCCoroutineSamplePlugin : SuspendingJavaPlugin() {\nprivate val database = Database()\nprivate val miniGame = MiniGame()\n\noverride suspend fun onEnableAsync() {\n// Minecraft Main Thread\ndatabase.createDbIfNotExist()\nserver.pluginManager.registerSuspendingEvents(PlayerDataListener(database), this)\ngetCommand(\"playerdata\")!!.setSuspendingExecutor(PlayerDataCommandExecutor(database))\nserver.pluginManager.registerSuspendingEvents(MiniGameListener(miniGame), this)\n}\n\noverride suspend fun onDisableAsync() {\n// Minecraft Main Thread\n}\n}\n</code></pre>"},{"location":"tasks/#test-the-minigame","title":"Test the MiniGame","text":"<p>Join your server to observe Minigame messages getting printed to your server log.</p>"},{"location":"timings/","title":"Timing Measurements","text":"<p>(This site is only relevant for Spigot, Paper and CraftBukkit)</p> <p>It is often the case, that we want to measure performance using timings https://timings.spigotmc.org/. However, Coroutines do not yield a meaningful task name per default e.g. <code>Task: CancellableContinuationImpl(Single)</code>, which makes it hard to debug for performance problems.</p> <p>As a solution, it is possible to pass an instance of <code>CoroutineTimings</code>, which is used to give the coroutine and its main thread tasks one meaningful name.</p> <p>For example, if you are starting a new coroutine like this:</p> <pre><code>plugin.launch {\nprintln(\"Please say hello in 2 seconds\")\ndelay(2000) // Delay for 2000 milliseconds\nprintln(\"hello\")\n}\n</code></pre> <p>Change it to the following:</p> <pre><code>plugin.launch(plugin.minecraftDispatcher + object : CoroutineTimings() {}) {\nprintln(\"Please say hello in 2 seconds\")\ndelay(2000) // Delay for 2000 milliseconds\nprintln(\"hello\")\n}\n</code></pre>"},{"location":"timings/#command-executors","title":"Command Executors","text":"<p>You can also assign a name to a <code>SuspendingCommandExecutor</code>. For this, add an object called <code>coroutineTimings</code> to your class implementing <code>SuspendingCommandExecutor</code>.</p> <pre><code>class MyCommandExecutor : SuspendingCommandExecutor {\n// Reference used for naming.\ncompanion object coroutineTimings : CoroutineTimings()\n\noverride suspend fun onCommand(\nsender: CommandSender,\ncommand: Command,\nlabel: String,\nargs: Array&lt;out String&gt;\n): Boolean {\nTODO(\"Not yet implemented\")\n}\n}\n</code></pre> <p>Register the <code>SuspendingCommandExecutor</code> in your plugin class as follows:</p> <pre><code>val myCommandExecutor = MyCommandExecutor()\nthis.getCommand(\"mycommand\")!!.setSuspendingExecutor(minecraftDispatcher + MyCommandExecutor.coroutineTimings, myCommandExecutor)\n</code></pre>"},{"location":"timings/#events","title":"Events","text":"<p>Event measurements are currently not supported by MCCoroutine. </p> <p>You can temporarily remove <code>suspend</code> from your event method, use <code>plugin.launch(plugin.minecraftDispatcher + object : CoroutineTimings() {}) {}</code>,  measure the time and then readd <code>suspend again.</code></p>"},{"location":"unittests/","title":"Unit-Tests with MCCoroutine","text":"<p>(This site is only relevant for Spigot, Paper and CraftBukkit. If you need Unit-Tests support for BungeeCord, Sponge or Velocity, please submit an issue on GitHub)</p> <p>If you try to write Unit- or IntegrationTests for your Minecraft plugin, you may need to test suspend functions. These functions may use <code>plugin.launch{...}</code> or other extension methods from MCCoroutine.</p> <p>However, extensive mocking is required to get MCCoroutine to work without a running server. As a solution to this problem, a new test dependency is available, which closely simulates MCCoroutine under real conditions. This means you can focus on writing your tests and get a very close feedback to the real environment.</p>"},{"location":"unittests/#1-add-the-dependency","title":"1. Add the dependency","text":"<p>Do not shade this library into your final plugin.jar file. This should only be available during UnitTests.</p> <pre><code>dependencies {\ntestImplementation(\"com.github.shynixn.mccoroutine:mccoroutine-bukkit-test:2.10.0\")\n}\n</code></pre>"},{"location":"unittests/#2-create-a-test-method","title":"2. Create a test method","text":"<pre><code>import org.junit.jupiter.api.Test\n\nclass MyExampleTest {\n@Test\nfun testCase01(){\n}\n}\n</code></pre>"},{"location":"unittests/#3-change-the-mccoroutine-production-driver-to-the-test-driver","title":"3. Change the MCCoroutine Production-Driver to the Test-Driver","text":"<pre><code>import org.junit.jupiter.api.Test\n\nclass MyExampleTest {\n\ninit {\n/**\n         * This switches MCCoroutine to the test implementation of MCCoroutine.\n         * It affects all the tests in the current session.\n         */\nMCCoroutine.Driver = TestMCCoroutine.Driver\n}\n\n@Test\nfun testCase01(){\n}\n}\n</code></pre>"},{"location":"unittests/#4-use-mccoroutine-in-the-same-way-as-on-your-server","title":"4. Use MCCoroutine in the same way as on your server","text":"<pre><code>import org.junit.jupiter.api.Test\n\nclass MyExampleTest {\n\ninit {\n/**\n         * This switches MCCoroutine to the test implementation of MCCoroutine.\n         * It affects all the tests in the current session.\n         */\nMCCoroutine.Driver = TestMCCoroutine.Driver\n}\n\n@Test\nfun testCase01(){\n// Uses the mocking library called Mockito to mock a plugin instance.\n// It does not matter how you create a plugin instance. Other mocking libraries work as well.\nval plugin = Mockito.mock(Plugin::class.java)\n\n// We need to use runBlocking here, otherwise the test exits early\nrunBlocking(plugin.minecraftDispatcher) {\nprintln(\"Step 1: \" + Thread.currentThread().name + \"/\" + Thread.currentThread().id)\n\nwithContext(Dispatchers.IO) {\nprintln(\"Step 2: \" + Thread.currentThread().name + \"/\" + Thread.currentThread().id)\ndelay(1000)\n}\n\nprintln(\"Step 3: \" + Thread.currentThread().name + \"/\" + Thread.currentThread().id)\n\n// As always, prefer using Dispatchers.IO instead of plugin.asyncDispatcher.\nwithContext(plugin.asyncDispatcher) {\nprintln(\"Step 4: \" + Thread.currentThread().name + \"/\" + Thread.currentThread().id)\ndelay(1000)\n}\n\nprintln(\"Step 5: \" + Thread.currentThread().name + \"/\" + Thread.currentThread().id)\n\n// Just as an example, we can also use plugin.launch\nplugin.launch {\nprintln(\"Step 6: \" + Thread.currentThread().name + \"/\" + Thread.currentThread().id)\ndelay(1000)\nprintln(\"Step 7: \" + Thread.currentThread().name + \"/\" + Thread.currentThread().id)\n}.join() // Wait until finished.\n}\n}\n}\n</code></pre>"}]}