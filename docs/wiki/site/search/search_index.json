{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction MCCoroutine is library which adds extensive support for Kotlin Coroutines on Minecraft Server implementing the Bukkit-API or Sponge-API . Examples for supported frameworks: Spigot Paper CraftBukkit SpongeVanilla SpongeForge Kotlin Coroutines Asynchronous or non-blocking programming is the new reality. Whether we're creating server-side, desktop or mobile applications, it's important that we provide an experience that is not only fluid from the user's perspective, but scalable when needed. There are many approaches to this problem, and in Kotlin we take a very flexible one by providing Coroutine support at the language level and delegating most of the functionality to libraries, much in line with Kotlin's philosophy. Source: (https://github.com/JetBrains/kotlin-web-site/blob/master/pages/docs/reference/coroutines-overview.md, Date: [09/11/2018], Licence copied to LICENCE). Features Full implementation of Kotlin Coroutines for Minecraft Server Extension functions for already established functions Connection to events, commands, schedulers Coroutine LifeCycle scope for plugins (supports plugin reloading) No NMS Support for Minecraft 1.7 - Latest Support for Java 8 - Latest Getting started Take a look at the next page to get started with integrating MCCoroutine into your plugin.","title":"Introduction"},{"location":"#introduction","text":"MCCoroutine is library which adds extensive support for Kotlin Coroutines on Minecraft Server implementing the Bukkit-API or Sponge-API . Examples for supported frameworks: Spigot Paper CraftBukkit SpongeVanilla SpongeForge Kotlin Coroutines Asynchronous or non-blocking programming is the new reality. Whether we're creating server-side, desktop or mobile applications, it's important that we provide an experience that is not only fluid from the user's perspective, but scalable when needed. There are many approaches to this problem, and in Kotlin we take a very flexible one by providing Coroutine support at the language level and delegating most of the functionality to libraries, much in line with Kotlin's philosophy. Source: (https://github.com/JetBrains/kotlin-web-site/blob/master/pages/docs/reference/coroutines-overview.md, Date: [09/11/2018], Licence copied to LICENCE).","title":"Introduction"},{"location":"#features","text":"Full implementation of Kotlin Coroutines for Minecraft Server Extension functions for already established functions Connection to events, commands, schedulers Coroutine LifeCycle scope for plugins (supports plugin reloading) No NMS Support for Minecraft 1.7 - Latest Support for Java 8 - Latest","title":"Features"},{"location":"#getting-started","text":"Take a look at the next page to get started with integrating MCCoroutine into your plugin.","title":"Getting started"},{"location":"bridge/","text":"Bridging non-suspendable functions to suspendable functions This guide continues the guide 'Creating a new Plugin' and describes how to bridge non suspendable code with suspendable implementations. 1. Adding plugin launch Use the extension method plugin.launch{} to enter a suspendable context on the bukkit primary thread. import com.github.shynixn.mccoroutine.launch import kotlinx.coroutines.delay import org.bukkit.plugin.Plugin class Foo ( private val plugin : Plugin ) { fun bar () { val job = plugin . launch { delay ( 1000 ) bob () } } private suspend fun bob (){ } } 2. Understanding the execution order. By allowing to append suspend to your listeners and command executors it is highly unlikely that you need to use this function. Still, it is important to understand the execution order in this case. class Foo ( private val plugin : Plugin ) { fun bar () { println ( \"I am first\" ) val job = plugin . launch { println ( \"I am second\" ) // The context is not suspended when switched to the same suspendable context. delay ( 1000 ) println ( \"I am fourth\" ) // The context is given back after 1000 milliseconds and continuous here. bob () } // When calling delay the suspendable context is suspended and the original context immediately continuous here. println ( \"I am third\" ) } private suspend fun bob (){ println ( \"I am fifth\" ) } } \"I am first \" I am second \"I am third\" \"I am fifth\" 3. Do not use runBlocking Using runBlocking in production code is very bad as it annihilates any improvements, we have made by using coroutines. MCCoroutine manipulates the Bukkit Scheduler to allow runBlocking during startup and disable but plugin.launch{} is almost always the function you want to use instead. 4. Test the Foo class Connect to the foo class in any way and call it for testing.","title":"Bridging non-suspendable functions to suspendable functions"},{"location":"bridge/#bridging-non-suspendable-functions-to-suspendable-functions","text":"This guide continues the guide 'Creating a new Plugin' and describes how to bridge non suspendable code with suspendable implementations.","title":"Bridging non-suspendable functions to suspendable functions"},{"location":"bridge/#1-adding-plugin-launch","text":"Use the extension method plugin.launch{} to enter a suspendable context on the bukkit primary thread. import com.github.shynixn.mccoroutine.launch import kotlinx.coroutines.delay import org.bukkit.plugin.Plugin class Foo ( private val plugin : Plugin ) { fun bar () { val job = plugin . launch { delay ( 1000 ) bob () } } private suspend fun bob (){ } }","title":"1. Adding plugin launch"},{"location":"bridge/#2-understanding-the-execution-order","text":"By allowing to append suspend to your listeners and command executors it is highly unlikely that you need to use this function. Still, it is important to understand the execution order in this case. class Foo ( private val plugin : Plugin ) { fun bar () { println ( \"I am first\" ) val job = plugin . launch { println ( \"I am second\" ) // The context is not suspended when switched to the same suspendable context. delay ( 1000 ) println ( \"I am fourth\" ) // The context is given back after 1000 milliseconds and continuous here. bob () } // When calling delay the suspendable context is suspended and the original context immediately continuous here. println ( \"I am third\" ) } private suspend fun bob (){ println ( \"I am fifth\" ) } } \"I am first \" I am second \"I am third\" \"I am fifth\"","title":"2. Understanding the execution order."},{"location":"bridge/#3-do-not-use-runblocking","text":"Using runBlocking in production code is very bad as it annihilates any improvements, we have made by using coroutines. MCCoroutine manipulates the Bukkit Scheduler to allow runBlocking during startup and disable but plugin.launch{} is almost always the function you want to use instead.","title":"3. Do not use runBlocking"},{"location":"bridge/#4-test-the-foo-class","text":"Connect to the foo class in any way and call it for testing.","title":"4. Test the Foo class"},{"location":"caching/","text":"Adding suspending caches and background tasks This guide continues the guide 'Creating a new Plugin' and describes how the caching strategy lazy loading can be used together with coroutines. 1. Add a simple cache When taking a look at the Database implementation from before, we can observe quite a lot of redundant database accesses when a player rejoins a server in a very short timeframe. For this, we put a lazy-loading cache in front of the Database implementation. import kotlinx.coroutines.Deferred import org.bukkit.entity.Player class DatabaseCache ( private val database : Database ) { private val cache = HashMap < Player , Deferred < PlayerData >> () suspend fun getDataFromPlayer ( player : Player ): PlayerData { } } 2. Deferred PlayerData Instead of using the type PlayerData directly, we use the type Deferred which is the representation of a non-blocking job which has got PlayerData as result. This means we essentially store the job of retrieving data from the database into the cache. import kotlinx.coroutines.* import org.bukkit.entity.Player import org.bukkit.plugin.Plugin class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( Dispatchers . IO ) { database . getDataFromPlayer ( player ) } } // Await suspends the current context until the value of the ``Deferred`` job is ready. cache [ player ]!! . await () } } } 3. Clear the cache Clearing the cache is as simple as adding a clear method. import kotlinx.coroutines.* import org.bukkit.entity.Player import org.bukkit.plugin.Plugin class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () fun clear () { cache . clear () } suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( Dispatchers . IO ) { database . getDataFromPlayer ( player ) } } // Await suspends the current context until the value of the ``Deferred`` job is ready. cache [ player ]!! . await () } } } 4. Adding auto save of cache It is possible to add a new suspendable repeatable background task to save the cached data every 10 minutes. import com.github.shynixn.mccoroutine.launch import kotlinx.coroutines.* import org.bukkit.entity.Player import org.bukkit.plugin.Plugin class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () init { // This plugin.launch launches a new scope in the minecraft server context which can be understood // to be a background task and behaves in a similar way to Bukkit.getScheduler().runTask(plugin, Runnable { }) plugin . launch { // This background task is a repeatable task which in this case is an endless loop. The endless loop // is automatically stopped by MCCoroutine once you reload your plugin. while ( true ) { // Save all cached player data every 10 minutes. for ( player in cache . keys . toTypedArray ()) { database . saveData ( player , cache [ player ]!! . await ()) // Remove player when no longer online if ( ! player . isOnline ) { cache . remove ( player ) } } // Suspending the current context is important in this case otherwise the minecraft thread will only execute this // endless loop as it does not have time to execute other things. Delay gives the thread time to execute other things. delay ( 10 * 60 * 1000 ) // 10 minutes } } } fun clear () { cache . clear () } suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( Dispatchers . IO ) { database . getDataFromPlayer ( player ) } } // Await suspends the current context until the value of the ``Deferred`` job is ready. cache [ player ]!! . await () } } } 5. Update PlayerDataListener It is no longer necessary to manually call save as auto save is put in place. Also, the cache automatically clears itself up every 10 minutes. import org.bukkit.event.EventHandler import org.bukkit.event.Listener import org.bukkit.event.player.PlayerJoinEvent import java.util.* class PlayerDataListener ( private val database : DatabaseCache ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( playerJoinEvent : PlayerJoinEvent ) { val player = playerJoinEvent . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastJoinDate = Date () } } 4. Test the Cache Join and leave your server to observe changes on your database.","title":"Suspending Caches, Background Repeating Tasks"},{"location":"caching/#adding-suspending-caches-and-background-tasks","text":"This guide continues the guide 'Creating a new Plugin' and describes how the caching strategy lazy loading can be used together with coroutines.","title":"Adding suspending caches and background tasks"},{"location":"caching/#1-add-a-simple-cache","text":"When taking a look at the Database implementation from before, we can observe quite a lot of redundant database accesses when a player rejoins a server in a very short timeframe. For this, we put a lazy-loading cache in front of the Database implementation. import kotlinx.coroutines.Deferred import org.bukkit.entity.Player class DatabaseCache ( private val database : Database ) { private val cache = HashMap < Player , Deferred < PlayerData >> () suspend fun getDataFromPlayer ( player : Player ): PlayerData { } }","title":"1. Add a simple cache"},{"location":"caching/#2-deferred-playerdata","text":"Instead of using the type PlayerData directly, we use the type Deferred which is the representation of a non-blocking job which has got PlayerData as result. This means we essentially store the job of retrieving data from the database into the cache. import kotlinx.coroutines.* import org.bukkit.entity.Player import org.bukkit.plugin.Plugin class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( Dispatchers . IO ) { database . getDataFromPlayer ( player ) } } // Await suspends the current context until the value of the ``Deferred`` job is ready. cache [ player ]!! . await () } } }","title":"2. Deferred PlayerData"},{"location":"caching/#3-clear-the-cache","text":"Clearing the cache is as simple as adding a clear method. import kotlinx.coroutines.* import org.bukkit.entity.Player import org.bukkit.plugin.Plugin class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () fun clear () { cache . clear () } suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( Dispatchers . IO ) { database . getDataFromPlayer ( player ) } } // Await suspends the current context until the value of the ``Deferred`` job is ready. cache [ player ]!! . await () } } }","title":"3. Clear the cache"},{"location":"caching/#4-adding-auto-save-of-cache","text":"It is possible to add a new suspendable repeatable background task to save the cached data every 10 minutes. import com.github.shynixn.mccoroutine.launch import kotlinx.coroutines.* import org.bukkit.entity.Player import org.bukkit.plugin.Plugin class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () init { // This plugin.launch launches a new scope in the minecraft server context which can be understood // to be a background task and behaves in a similar way to Bukkit.getScheduler().runTask(plugin, Runnable { }) plugin . launch { // This background task is a repeatable task which in this case is an endless loop. The endless loop // is automatically stopped by MCCoroutine once you reload your plugin. while ( true ) { // Save all cached player data every 10 minutes. for ( player in cache . keys . toTypedArray ()) { database . saveData ( player , cache [ player ]!! . await ()) // Remove player when no longer online if ( ! player . isOnline ) { cache . remove ( player ) } } // Suspending the current context is important in this case otherwise the minecraft thread will only execute this // endless loop as it does not have time to execute other things. Delay gives the thread time to execute other things. delay ( 10 * 60 * 1000 ) // 10 minutes } } } fun clear () { cache . clear () } suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( Dispatchers . IO ) { database . getDataFromPlayer ( player ) } } // Await suspends the current context until the value of the ``Deferred`` job is ready. cache [ player ]!! . await () } } }","title":"4. Adding auto save of cache"},{"location":"caching/#5-update-playerdatalistener","text":"It is no longer necessary to manually call save as auto save is put in place. Also, the cache automatically clears itself up every 10 minutes. import org.bukkit.event.EventHandler import org.bukkit.event.Listener import org.bukkit.event.player.PlayerJoinEvent import java.util.* class PlayerDataListener ( private val database : DatabaseCache ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( playerJoinEvent : PlayerJoinEvent ) { val player = playerJoinEvent . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastJoinDate = Date () } }","title":"5. Update PlayerDataListener"},{"location":"caching/#4-test-the-cache","text":"Join and leave your server to observe changes on your database.","title":"4. Test the Cache"},{"location":"commandexecutors/","text":"Adding suspending commandExecutors This guide continues the guide 'Creating a new Plugin' and describes how command executors can be used to edit player data. 1. Create the CommandExecutor class Create a traditional CommandExecutor but implement SuspendingCommandExecutor instead of CommandExecutor . Please consider that the return value true is automatically assumed if the function is suspended in one branch. import com.github.shynixn.mccoroutine.SuspendingCommandExecutor import org.bukkit.command.Command import org.bukkit.command.CommandSender import org.bukkit.entity.Player class PlayerDataCommandExecutor ( private val database : Database ) : SuspendingCommandExecutor { override suspend fun onCommand ( sender : CommandSender , command : Command , label : String , args : Array < out String > ): Boolean { if ( sender !is Player ) { return false } if ( args . size == 2 && args [ 0 ] . equals ( \"rename\" , true )) { val name = args [ 1 ] val playerData = database . getDataFromPlayer ( sender ) playerData . name = name database . saveData ( sender , playerData ) return true } return false } } 2. Connect JavaPlugin and PlayerDataCommandExecutor Instead of using setExecutor , use the provided extension method setSuspendingExecutor to allow to register a suspendable command executor. Important Do not forget to declare the playerdata command in your plugin.yml. import com.github.shynixn.mccoroutine.SuspendingJavaPlugin import com.github.shynixn.mccoroutine.registerSuspendingEvents import com.github.shynixn.mccoroutine.setSuspendingExecutor class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), plugin ) getCommand ( \"playerdata\" ) !! . setSuspendingExecutor ( PlayerDataCommandExecutor ( database )) } override suspend fun onDisableAsync () { } } 3. Test the CommandExecutor Join your server and use the playerData command to observe getDataFromPlayer and saveData messages print to your server log. The next page continuous by adding repeating and delayed tasks to the plugin.","title":"Suspending CommandExecutors"},{"location":"commandexecutors/#adding-suspending-commandexecutors","text":"This guide continues the guide 'Creating a new Plugin' and describes how command executors can be used to edit player data.","title":"Adding suspending commandExecutors"},{"location":"commandexecutors/#1-create-the-commandexecutor-class","text":"Create a traditional CommandExecutor but implement SuspendingCommandExecutor instead of CommandExecutor . Please consider that the return value true is automatically assumed if the function is suspended in one branch. import com.github.shynixn.mccoroutine.SuspendingCommandExecutor import org.bukkit.command.Command import org.bukkit.command.CommandSender import org.bukkit.entity.Player class PlayerDataCommandExecutor ( private val database : Database ) : SuspendingCommandExecutor { override suspend fun onCommand ( sender : CommandSender , command : Command , label : String , args : Array < out String > ): Boolean { if ( sender !is Player ) { return false } if ( args . size == 2 && args [ 0 ] . equals ( \"rename\" , true )) { val name = args [ 1 ] val playerData = database . getDataFromPlayer ( sender ) playerData . name = name database . saveData ( sender , playerData ) return true } return false } }","title":"1. Create the CommandExecutor class"},{"location":"commandexecutors/#2-connect-javaplugin-and-playerdatacommandexecutor","text":"Instead of using setExecutor , use the provided extension method setSuspendingExecutor to allow to register a suspendable command executor. Important Do not forget to declare the playerdata command in your plugin.yml. import com.github.shynixn.mccoroutine.SuspendingJavaPlugin import com.github.shynixn.mccoroutine.registerSuspendingEvents import com.github.shynixn.mccoroutine.setSuspendingExecutor class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), plugin ) getCommand ( \"playerdata\" ) !! . setSuspendingExecutor ( PlayerDataCommandExecutor ( database )) } override suspend fun onDisableAsync () { } }","title":"2. Connect JavaPlugin and PlayerDataCommandExecutor"},{"location":"commandexecutors/#3-test-the-commandexecutor","text":"Join your server and use the playerData command to observe getDataFromPlayer and saveData messages print to your server log. The next page continuous by adding repeating and delayed tasks to the plugin.","title":"3. Test the CommandExecutor"},{"location":"gettingstarted/","text":"Getting Started In order to access the MCCoroutine Kotlin API, you need to include the following libraries into your project. Further help Please take a look at the sample plugins mccoroutine-bukkit-sample or mccoroutine-sponge-sample which can be found on Github . A real production plugin using MCCoroutine can be found here . Sponge Documentation Please notice that these are the libraries for Bukkit-API based servers. If you are looking for the Sponge-API, simply replace bukkit with sponge in name of the dependencies. e.g. 'com.github.shynixn.mccoroutine:mccoroutine-sponge-api: x.x.x' - Sponge Documentation 1. Add MCCoroutine Gradle dependencies { implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-api:1.4.0\" ) implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-core:1.4.0\" ) } Maven <dependency> <groupId> com.github.shynixn.mccoroutine </groupId> <artifactId> mccoroutine-bukkit-api </artifactId> <version> 1.4.0 </version> <scope> compile </scope> </dependency> <dependency> <groupId> com.github.shynixn.mccoroutine </groupId> <artifactId> mccoroutine-bukkit-core </artifactId> <version> 1.4.0 </version> <scope> compile </scope> </dependency> 2. Add the official Kotlin Coroutines libraries MCCoroutine builds against Kotlin 1.3.x but does not ship the Kotlin Runtime or Kotlin Coroutines Runtime. This means you are free to choose any ship your Kotlin Runtime as you like as long it is >= 1.3.0. Replace 1.x.x with the actual versions. Gradle dependencies { implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.x.x\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.x.x\" ) } Maven <dependency> <groupId> org.jetbrains.kotlinx </groupId> <artifactId> kotlinx-coroutines-core </artifactId> <version> 1.x.x </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.jetbrains.kotlinx </groupId> <artifactId> kotlinx-coroutines-jdk8 </artifactId> <version> 1.x.x </version> <scope> compile </scope> </dependency> 3. Test if everything is working Try to call launch{} in your onEnable() function in your Plugin class.","title":"Getting Started"},{"location":"gettingstarted/#getting-started","text":"In order to access the MCCoroutine Kotlin API, you need to include the following libraries into your project. Further help Please take a look at the sample plugins mccoroutine-bukkit-sample or mccoroutine-sponge-sample which can be found on Github . A real production plugin using MCCoroutine can be found here . Sponge Documentation Please notice that these are the libraries for Bukkit-API based servers. If you are looking for the Sponge-API, simply replace bukkit with sponge in name of the dependencies. e.g. 'com.github.shynixn.mccoroutine:mccoroutine-sponge-api: x.x.x' - Sponge Documentation","title":"Getting Started"},{"location":"gettingstarted/#1-add-mccoroutine","text":"Gradle dependencies { implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-api:1.4.0\" ) implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-core:1.4.0\" ) } Maven <dependency> <groupId> com.github.shynixn.mccoroutine </groupId> <artifactId> mccoroutine-bukkit-api </artifactId> <version> 1.4.0 </version> <scope> compile </scope> </dependency> <dependency> <groupId> com.github.shynixn.mccoroutine </groupId> <artifactId> mccoroutine-bukkit-core </artifactId> <version> 1.4.0 </version> <scope> compile </scope> </dependency>","title":"1. Add MCCoroutine"},{"location":"gettingstarted/#2-add-the-official-kotlin-coroutines-libraries","text":"MCCoroutine builds against Kotlin 1.3.x but does not ship the Kotlin Runtime or Kotlin Coroutines Runtime. This means you are free to choose any ship your Kotlin Runtime as you like as long it is >= 1.3.0. Replace 1.x.x with the actual versions. Gradle dependencies { implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.x.x\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.x.x\" ) } Maven <dependency> <groupId> org.jetbrains.kotlinx </groupId> <artifactId> kotlinx-coroutines-core </artifactId> <version> 1.x.x </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.jetbrains.kotlinx </groupId> <artifactId> kotlinx-coroutines-jdk8 </artifactId> <version> 1.x.x </version> <scope> compile </scope> </dependency>","title":"2. Add the official Kotlin Coroutines libraries"},{"location":"gettingstarted/#3-test-if-everything-is-working","text":"Try to call launch{} in your onEnable() function in your Plugin class.","title":"3. Test if everything is working"},{"location":"listener/","text":"Adding suspending listeners This guide continues the guide 'Creating a new Plugin' and describes how listeners can be used to load and save player data. 1. Create the Listener class Create a traditional listener and add suspend to all functions where you perform suspendable operations (e.g. calling other suspend functions). You can mix suspendable and non suspendable functions in listeners. import org.bukkit.event.EventHandler import org.bukkit.event.Listener import org.bukkit.event.player.PlayerJoinEvent import org.bukkit.event.player.PlayerQuitEvent import java.util.* class PlayerDataListener ( private val database : Database ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( playerJoinEvent : PlayerJoinEvent ) { val player = playerJoinEvent . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastJoinDate = Date () database . saveData ( player , playerData ) } @EventHandler suspend fun onPlayerQuitEvent ( playerQuitEvent : PlayerQuitEvent ) { val player = playerQuitEvent . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastQuitDate = Date () database . saveData ( player , playerData ) } } 2. Connect JavaPlugin and PlayerDataListener Instead of using registerEvents , use the provided extension method registerSuspendingEvents to allow suspendable functions in your listener. Please consider, that timing measurements are no longer accurate for suspendable functions. import com.github.shynixn.mccoroutine.SuspendingJavaPlugin import com.github.shynixn.mccoroutine.registerSuspendingEvents class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), this ) } override suspend fun onDisableAsync () { } } 3. Test the Listener Join and leave your server to observe getDataFromPlayer and saveData messages print to your server log. Extend it with real database operations to get familiar with how it works. The next page continuous by adding command executors to the plugin.","title":"Suspending Listeners"},{"location":"listener/#adding-suspending-listeners","text":"This guide continues the guide 'Creating a new Plugin' and describes how listeners can be used to load and save player data.","title":"Adding suspending listeners"},{"location":"listener/#1-create-the-listener-class","text":"Create a traditional listener and add suspend to all functions where you perform suspendable operations (e.g. calling other suspend functions). You can mix suspendable and non suspendable functions in listeners. import org.bukkit.event.EventHandler import org.bukkit.event.Listener import org.bukkit.event.player.PlayerJoinEvent import org.bukkit.event.player.PlayerQuitEvent import java.util.* class PlayerDataListener ( private val database : Database ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( playerJoinEvent : PlayerJoinEvent ) { val player = playerJoinEvent . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastJoinDate = Date () database . saveData ( player , playerData ) } @EventHandler suspend fun onPlayerQuitEvent ( playerQuitEvent : PlayerQuitEvent ) { val player = playerQuitEvent . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastQuitDate = Date () database . saveData ( player , playerData ) } }","title":"1. Create the Listener class"},{"location":"listener/#2-connect-javaplugin-and-playerdatalistener","text":"Instead of using registerEvents , use the provided extension method registerSuspendingEvents to allow suspendable functions in your listener. Please consider, that timing measurements are no longer accurate for suspendable functions. import com.github.shynixn.mccoroutine.SuspendingJavaPlugin import com.github.shynixn.mccoroutine.registerSuspendingEvents class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), this ) } override suspend fun onDisableAsync () { } }","title":"2. Connect JavaPlugin and PlayerDataListener"},{"location":"listener/#3-test-the-listener","text":"Join and leave your server to observe getDataFromPlayer and saveData messages print to your server log. Extend it with real database operations to get familiar with how it works. The next page continuous by adding command executors to the plugin.","title":"3. Test the Listener"},{"location":"newplugin/","text":"Creating a new plugin This guide deals with an example where a new plugin is developed from scratch using MCCoroutine to handle asynchronous and synchronous code. MCCoroutine can be easily integrated into existing plugins but this guide only deals with a new plugin. 1. Understanding the goal We want to create a new plugin which stores/retrieves the following user data into/from a database when a user enters our Bukkit-API based server. UUID Player Name Last Join Date Last Quit Date 2. Include MCCoroutine and Kotlin Coroutines This example plugin uses gradle as a build system. For more details see the Started Page . Gradle Important Please use your own Kotlin version and the latest mccoroutine version instead. This is just a working example. dependencies { implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-api:1.4.0\" ) implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-core:1.4.0\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.10\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.3.10\" ) } 3. Create the Java Plugin class Here the first decision is to decide between extending JavaPlugin or SuspendingJavaPlugin which is a new base class extending JavaPlugin . Here is an easy rule to follow: If you want to perform async operations or call other suspending functions from your plugin class, go with the newly available type SuspendingJavaPlugin otherwise use JavaPlugin . import com.github.shynixn.mccoroutine.SuspendingJavaPlugin class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { override suspend fun onEnableAsync () { } override suspend fun onDisableAsync () { } } How onEnableAsync works The implementation which calls the onEnableAsync function manipulates the Bukkit Server implementation in the following way: If a context switch is made, it blocks the entire minecraft-server thread until the context is given back. This means in this method you can switch contexts as you like but the plugin is not considered enabled until the context is given back. It allows for a clean startup as the plugin is not considered \"enabled\" until the context is given back. Other plugins which are already enabled, may or may not already perform work in the background. Plugins which may get enabled in the future, wait until this plugin is enabled. 3. Create Database and PlayerData class class PlayerData ( var uuid : UUID , var name : String , var lastJoinDate : Date , var lastQuitDate : Date ) { } Here, we perform all database operations on the IO context provided by Kotlin Coroutines. The result is automatically returned to the Bukkit primary thread. import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import org.bukkit.entity.Player import java.util.* class Database () { suspend fun createDbIfNotExist () { println ( \"[createDbIfNotExist] Start on minecraft thread \" + Thread . currentThread (). id ) withContext ( Dispatchers . IO ){ println ( \"[createDbIfNotExist] Creating database on database io thread \" + Thread . currentThread (). id ) // ... create tables } println ( \"[createDbIfNotExist] End on minecraft thread \" + Thread . currentThread (). id ) } suspend fun getDataFromPlayer ( player : Player ) : PlayerData { println ( \"[getDataFromPlayer] Start on minecraft thread \" + Thread . currentThread (). id ) val playerData = withContext ( Dispatchers . IO ) { println ( \"[getDataFromPlayer] Retrieving player data on database io thread \" + Thread . currentThread (). id ) // ... get from database by player uuid or create new playerData instance. PlayerData ( player . uniqueId , player . name , Date (), Date ()) } println ( \"[getDataFromPlayer] End on minecraft thread \" + Thread . currentThread (). id ) return playerData ; } suspend fun saveData ( player : Player , playerData : PlayerData ) { println ( \"[saveData] Start on minecraft thread \" + Thread . currentThread (). id ) withContext ( Dispatchers . IO ){ println ( \"[saveData] Saving player data on database io thread \" + Thread . currentThread (). id ) // insert or update playerData } println ( \"[saveData] End on minecraft thread \" + Thread . currentThread (). id ) } } 4. Connect JavaPlugin and Database Create a new instance of the database and call it in the onEnable function. import com.github.shynixn.mccoroutine.SuspendingJavaPlugin class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { database . createDbIfNotExist () } override suspend fun onDisableAsync () { } } 5. Test the Java Plugin Start your server to observe the createDbIfNotExist messages print to your server log. Extend it with real database operations to get familiar with how it works. The next page continuous by adding listeners to the plugin.","title":"Creating a new Plugin"},{"location":"newplugin/#creating-a-new-plugin","text":"This guide deals with an example where a new plugin is developed from scratch using MCCoroutine to handle asynchronous and synchronous code. MCCoroutine can be easily integrated into existing plugins but this guide only deals with a new plugin.","title":"Creating a new plugin"},{"location":"newplugin/#1-understanding-the-goal","text":"We want to create a new plugin which stores/retrieves the following user data into/from a database when a user enters our Bukkit-API based server. UUID Player Name Last Join Date Last Quit Date","title":"1. Understanding the goal"},{"location":"newplugin/#2-include-mccoroutine-and-kotlin-coroutines","text":"This example plugin uses gradle as a build system. For more details see the Started Page . Gradle Important Please use your own Kotlin version and the latest mccoroutine version instead. This is just a working example. dependencies { implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-api:1.4.0\" ) implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-core:1.4.0\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.10\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.3.10\" ) }","title":"2. Include MCCoroutine and Kotlin Coroutines"},{"location":"newplugin/#3-create-the-java-plugin-class","text":"Here the first decision is to decide between extending JavaPlugin or SuspendingJavaPlugin which is a new base class extending JavaPlugin . Here is an easy rule to follow: If you want to perform async operations or call other suspending functions from your plugin class, go with the newly available type SuspendingJavaPlugin otherwise use JavaPlugin . import com.github.shynixn.mccoroutine.SuspendingJavaPlugin class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { override suspend fun onEnableAsync () { } override suspend fun onDisableAsync () { } } How onEnableAsync works The implementation which calls the onEnableAsync function manipulates the Bukkit Server implementation in the following way: If a context switch is made, it blocks the entire minecraft-server thread until the context is given back. This means in this method you can switch contexts as you like but the plugin is not considered enabled until the context is given back. It allows for a clean startup as the plugin is not considered \"enabled\" until the context is given back. Other plugins which are already enabled, may or may not already perform work in the background. Plugins which may get enabled in the future, wait until this plugin is enabled.","title":"3. Create the Java Plugin class"},{"location":"newplugin/#3-create-database-and-playerdata-class","text":"class PlayerData ( var uuid : UUID , var name : String , var lastJoinDate : Date , var lastQuitDate : Date ) { } Here, we perform all database operations on the IO context provided by Kotlin Coroutines. The result is automatically returned to the Bukkit primary thread. import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import org.bukkit.entity.Player import java.util.* class Database () { suspend fun createDbIfNotExist () { println ( \"[createDbIfNotExist] Start on minecraft thread \" + Thread . currentThread (). id ) withContext ( Dispatchers . IO ){ println ( \"[createDbIfNotExist] Creating database on database io thread \" + Thread . currentThread (). id ) // ... create tables } println ( \"[createDbIfNotExist] End on minecraft thread \" + Thread . currentThread (). id ) } suspend fun getDataFromPlayer ( player : Player ) : PlayerData { println ( \"[getDataFromPlayer] Start on minecraft thread \" + Thread . currentThread (). id ) val playerData = withContext ( Dispatchers . IO ) { println ( \"[getDataFromPlayer] Retrieving player data on database io thread \" + Thread . currentThread (). id ) // ... get from database by player uuid or create new playerData instance. PlayerData ( player . uniqueId , player . name , Date (), Date ()) } println ( \"[getDataFromPlayer] End on minecraft thread \" + Thread . currentThread (). id ) return playerData ; } suspend fun saveData ( player : Player , playerData : PlayerData ) { println ( \"[saveData] Start on minecraft thread \" + Thread . currentThread (). id ) withContext ( Dispatchers . IO ){ println ( \"[saveData] Saving player data on database io thread \" + Thread . currentThread (). id ) // insert or update playerData } println ( \"[saveData] End on minecraft thread \" + Thread . currentThread (). id ) } }","title":"3. Create Database and PlayerData class"},{"location":"newplugin/#4-connect-javaplugin-and-database","text":"Create a new instance of the database and call it in the onEnable function. import com.github.shynixn.mccoroutine.SuspendingJavaPlugin class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { database . createDbIfNotExist () } override suspend fun onDisableAsync () { } }","title":"4. Connect JavaPlugin and Database"},{"location":"newplugin/#5-test-the-java-plugin","text":"Start your server to observe the createDbIfNotExist messages print to your server log. Extend it with real database operations to get familiar with how it works. The next page continuous by adding listeners to the plugin.","title":"5. Test the Java Plugin"},{"location":"repeatingtasks/","text":"Adding delayed and repeating tasks This guide continues the guide 'Creating a new Plugin' and describes how delayed and repeating tasks can be performed with coroutines. 1. Create MiniGame class Create a new class which implements a custom MiniGame which allows players to join when it has not started yet. import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () fun join ( player : Player ) { if ( isStarted ) { return ; } players . add ( player ) } } 2. Add a start function to the MiniGame class Using delay() we can delay the current context (Bukkit primary thread) by 1000 milliseconds, to easily generate a countdown without blocking the server. delay() essentially suspends the current context and continuous after the given time. Difference between delay() and Thread.sleep() There is a big difference with delay() and Thread.sleep() . Consult the official Kotlin Coroutines documentation for details, however essentially Thread.sleep() blocks the thread for a given time and delay() suspends the thread for a given time. When a thread is suspended, it can do other work (e.g. server handles other operations like players joining or commands) compared to when a thread is blocked, it cannot do other work (e.g. server appears frozen). import kotlinx.coroutines.delay import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () fun join ( player : Player ) { if ( isStarted ) { return } players . add ( player ) } suspend fun start () { if ( isStarted ) { return } isStarted = true // This loop represents a traditional repeating task which ticks every 1 second and is called 20 times. for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. } private fun sendMessageToPlayers ( message : String ) { players . forEach { p -> p . sendMessage ( message ) } } } 3. Add a run function to the MiniGame class We can extend the start method to call run which contains a loop to tick the miniGame every 1 second. import kotlinx.coroutines.delay import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 //... suspend fun start () { if ( isStarted ) { return } isStarted = true // This loop represents a traditional repeating task which ticks every 1 second and is called 20 times. for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. run () } private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } } //... } 4. Add a function to stop the game. An admin should be able to cancel the minigame which we implement by a stop function. import kotlinx.coroutines.delay import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 //... private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } if ( ! isStarted ) { sendMessageToPlayers ( \"Game was cancelled by external stop.\" ) } isStarted = false // ... Teleport players back to lobby. } fun stop () { if ( ! isStarted ) { return } isStarted = false } //... } 5. The full MiniGame class import kotlinx.coroutines.delay import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 fun join ( player : Player ) { if ( isStarted ) { return } players . add ( player ) } suspend fun start () { if ( isStarted ) { return } isStarted = true // This loop represents a traditional repeating task which ticks every 1 second and is called 20 times. for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. run () } private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } if ( ! isStarted ) { sendMessageToPlayers ( \"Game was cancelled by external stop.\" ) } isStarted = false // ... Teleport players back to lobby. } fun stop () { if ( ! isStarted ) { return } isStarted = false } private fun sendMessageToPlayers ( message : String ) { players . forEach { p -> p . sendMessage ( message ) } } } 6. Connect JavaPlugin, Listener and MiniGame import org.bukkit.event.EventHandler import org.bukkit.event.Listener import org.bukkit.event.player.PlayerJoinEvent class MiniGameListener ( private val miniGame : MiniGame ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( playerJoinEvent : PlayerJoinEvent ) { miniGame . join ( playerJoinEvent . player ) // Just for testing purposes miniGame . start () } } import com.github.shynixn.mccoroutine.SuspendingJavaPlugin import com.github.shynixn.mccoroutine.registerSuspendingEvents import com.github.shynixn.mccoroutine.setSuspendingExecutor class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () private val miniGame = MiniGame () override suspend fun onEnableAsync () { database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), this ) getCommand ( \"playerdata\" ) !! . setSuspendingExecutor ( PlayerDataCommandExecutor ( database )) server . pluginManager . registerSuspendingEvents ( MiniGameListener ( miniGame ), this ) } override suspend fun onDisableAsync () { } } 7. Test the MiniGame Join your server to observe Minigame messages print to your server log. The next page continuous by adding caches using background-delayed-repeating tasks.","title":"Suspending Delayed, Repeating Tasks"},{"location":"repeatingtasks/#adding-delayed-and-repeating-tasks","text":"This guide continues the guide 'Creating a new Plugin' and describes how delayed and repeating tasks can be performed with coroutines.","title":"Adding delayed and repeating tasks"},{"location":"repeatingtasks/#1-create-minigame-class","text":"Create a new class which implements a custom MiniGame which allows players to join when it has not started yet. import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () fun join ( player : Player ) { if ( isStarted ) { return ; } players . add ( player ) } }","title":"1. Create MiniGame class"},{"location":"repeatingtasks/#2-add-a-start-function-to-the-minigame-class","text":"Using delay() we can delay the current context (Bukkit primary thread) by 1000 milliseconds, to easily generate a countdown without blocking the server. delay() essentially suspends the current context and continuous after the given time. Difference between delay() and Thread.sleep() There is a big difference with delay() and Thread.sleep() . Consult the official Kotlin Coroutines documentation for details, however essentially Thread.sleep() blocks the thread for a given time and delay() suspends the thread for a given time. When a thread is suspended, it can do other work (e.g. server handles other operations like players joining or commands) compared to when a thread is blocked, it cannot do other work (e.g. server appears frozen). import kotlinx.coroutines.delay import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () fun join ( player : Player ) { if ( isStarted ) { return } players . add ( player ) } suspend fun start () { if ( isStarted ) { return } isStarted = true // This loop represents a traditional repeating task which ticks every 1 second and is called 20 times. for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. } private fun sendMessageToPlayers ( message : String ) { players . forEach { p -> p . sendMessage ( message ) } } }","title":"2. Add a start function to the MiniGame class"},{"location":"repeatingtasks/#3-add-a-run-function-to-the-minigame-class","text":"We can extend the start method to call run which contains a loop to tick the miniGame every 1 second. import kotlinx.coroutines.delay import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 //... suspend fun start () { if ( isStarted ) { return } isStarted = true // This loop represents a traditional repeating task which ticks every 1 second and is called 20 times. for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. run () } private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } } //... }","title":"3. Add a run function to the MiniGame class"},{"location":"repeatingtasks/#4-add-a-function-to-stop-the-game","text":"An admin should be able to cancel the minigame which we implement by a stop function. import kotlinx.coroutines.delay import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 //... private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } if ( ! isStarted ) { sendMessageToPlayers ( \"Game was cancelled by external stop.\" ) } isStarted = false // ... Teleport players back to lobby. } fun stop () { if ( ! isStarted ) { return } isStarted = false } //... }","title":"4. Add a function to stop the game."},{"location":"repeatingtasks/#5-the-full-minigame-class","text":"import kotlinx.coroutines.delay import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 fun join ( player : Player ) { if ( isStarted ) { return } players . add ( player ) } suspend fun start () { if ( isStarted ) { return } isStarted = true // This loop represents a traditional repeating task which ticks every 1 second and is called 20 times. for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. run () } private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } if ( ! isStarted ) { sendMessageToPlayers ( \"Game was cancelled by external stop.\" ) } isStarted = false // ... Teleport players back to lobby. } fun stop () { if ( ! isStarted ) { return } isStarted = false } private fun sendMessageToPlayers ( message : String ) { players . forEach { p -> p . sendMessage ( message ) } } }","title":"5. The full MiniGame class"},{"location":"repeatingtasks/#6-connect-javaplugin-listener-and-minigame","text":"import org.bukkit.event.EventHandler import org.bukkit.event.Listener import org.bukkit.event.player.PlayerJoinEvent class MiniGameListener ( private val miniGame : MiniGame ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( playerJoinEvent : PlayerJoinEvent ) { miniGame . join ( playerJoinEvent . player ) // Just for testing purposes miniGame . start () } } import com.github.shynixn.mccoroutine.SuspendingJavaPlugin import com.github.shynixn.mccoroutine.registerSuspendingEvents import com.github.shynixn.mccoroutine.setSuspendingExecutor class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () private val miniGame = MiniGame () override suspend fun onEnableAsync () { database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), this ) getCommand ( \"playerdata\" ) !! . setSuspendingExecutor ( PlayerDataCommandExecutor ( database )) server . pluginManager . registerSuspendingEvents ( MiniGameListener ( miniGame ), this ) } override suspend fun onDisableAsync () { } }","title":"6. Connect JavaPlugin, Listener and MiniGame"},{"location":"repeatingtasks/#7-test-the-minigame","text":"Join your server to observe Minigame messages print to your server log. The next page continuous by adding caches using background-delayed-repeating tasks.","title":"7. Test the MiniGame"}]}